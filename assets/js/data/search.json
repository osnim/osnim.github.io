



[ { "title": "스프링 입문 23 - 8.AOP (1)", "url": "/posts/Inflearn-spring23/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-22 13:56:00 +0900", "snippet": "AOP(Aspect Oriented Programming)AOP란 Aspect Oriented Programming의 약자로 관점 지향 프로그래밍이라고 합니다.시간 측정 로직먼저 AOP에 대한 자세한 설명을 바로 시작하지 않고 다음과 같은 상황을 가정해보겠습니다. 만약 모든 메소드의 호출시간을 측정하고 싶다면 어떻게 해야할까? 각 메서드 마다 System.currentTimeMillis() 를 이용하여 끝 - 시간을 계산하면 됩니다.코드로 시간 측정 로직을 구현하면 다음과 같습니다. 예를 들어 join 메서드의 시간을 측정하고 싶다면 위와 같이 변경해야합니다.위 코드의 문제점 만약 메서드가 약 몇 천 ~ 몇 만 단위로 커진다면 이렇게 코딩을 하는 것을 매우 비효율적입니다. 회원가입, 회원 조회에 시간을 측정하는 기능은 핵심 관심 사항이 아닙니다. 시간을 측정하는 로직과 핵심 비즈니스의 로직이 섞여서 유지보수가 어렵다. 시간을 측정하는 로직을 변경할 때 모든 로직을 찾아가면서 변경해야 한다. 시간을 측정하는 로직은 공통 관심 사항입니다.AOP 적용AOP의 핵심은 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern) 분리하는 것입니다.모든 메서드에 시간 측정 로직을 구현하는 것이 아니라 시간 측정 로직만 따로 분리시켜 원하는 메소드에 적용하는 것입니다.스프링에서는 AOP 기술을 쉽게 적용할 수 있게 제공을 합니다.AOP 코드aop라는 패키지를 만들고 그 안에 TimeTraceAop 클래스를 생성합니다. 그 후 @Aspect 를 추가합니다. AOP 기능을 사용하기 위해서는 @Aspect가 필요합니다.AOP 코드는 메뉴얼을 그대로 따라합니다.@Around(&quot;execution(* Hello.Hellospring..*(..))&quot;)위 코드는 Hello.Hellospring 패키지 하위에 이 AOP를 모두 적용시킨다는 의미입니다.위 코드를 통해 어떻게 메서드를 들어가고 어디서 병목현상이 발생했는지 바로 확인할 수 있습니다.AOP의 핵심 public Object execute(ProceedingJoinPoint joinPoint)위 코드에서 joinPoint를 통해 AOP를 조작할 수 있습니다.AOP 결과 회원가입, 회원 조회등 핵심 관심사항과 시간을 측정하는 공통 관심 사항을 분리하여 시간을 측정하는 로직을 별도의 공통 로직으로 만들었습니다. 핵심 관심 사항을 깔끔하게 유지할 수 있으며 변경이 필요하면 이 로직만 변경하면 됩니다.스프링의 AOP 동작 방식 설명스프링에서는 AOP가 적용되면 가짜 memberService를 생성합니다 이것이 프록시 memberService 라고 합니다. 그리고 스프링 컨테이너에 memberService 스프링 빈을 등록할 때, 가짜 memberService 스프링 빈을 실행하고 그 실행이 완료되면 joinPoint.proceed()를 실행하여 다음 진짜 memberService을 실행합니다.즉, helloController가 호출하는 것은 프록시 기술로 생성한 가짜 memberService 입니다.AOP는 스프링이 DI 기능을 지원해줘서 가능합니다. 스프링이 알아서 DI를 해주기 때문에 직접 설정해줄 필요없이 받아만 쓰는 메서드 입장에서는 프록시인지 진짜인지 구별 안하기 때문입니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert 생성자가 1개인 경우 @Autowired 생략 가능이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 22 - 7.스프링 DB 접근 기술 (6)", "url": "/posts/Inflearn-spring22/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-21 03:14:00 +0900", "snippet": "스프링 데이터 JPA (Java Persistence API)이전 강의를 통해서 스프링 부트와 JPA만 사용해도 개발 생산성이 많이 증가하는 것을 확인할 수 있었습니다. 추가로 스프링 데이터 JPA를 사용하면, 기존의 한계를 넘어 리포지토리 구현 클래스 없이 인터페이스만으로 개발을 할 수 있습니다.개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공합니다. 따라서 개발자는 핵심 비즈니스 로직을 개발하는데, 집중할 수 있습니다.주의할 점은 스프링 데이터 JPA는 JPA를 편리하게 사용하도록 도와주는 기술입니다. 따라서 JPA를 먼저 학습한후에 스프링 데이터 JPA를 학습을 권장합니다.스프링 데이터 JPA 회원 리포지토리repository 폴더에 SpringDataJpaMemberRepository 클래스가 아닌 인터페이스로 생성합니다.참고로 인터페이스가 인터페이스를 상속 받을 떄는 implements가 아니라 extends를 사용합니다.인터페이스는 다중 상속이 되기 때문에 JpaRepository&amp;lt;Member, Long&amp;gt;, MemberRepository 두개를 상속 받습니다.@Override Optional&amp;lt;Member&amp;gt; findByName(String name);이렇게 하면 다른 메서드 추가 없이 JPA를 사용할 수 있습니다.스프링 데이터 JPA 회원 리포지토리를 사용하도록 스프링 설정 변경스프링 데이터 JPA가 JpaRepository를 상속 받고 있으면 구현체를 자동으로 만들어 줍니다. 그리고 스프링 데이터 JPA가 구현체인 SpringDataJpaMemberRepository를 스프링 빈에 자동으로 등록합니다. 저희는 그것을 손쉽게 가져다 사용하기만 하면 됩니다.SpringConfig를 위와 같이 변경합니다.테스트 실행Hibernate가 뜨며 정상적으로 작동하는 것을 확인할 수 있었습니다.설명JpaRepository 인터페이스 내부에서 저희가 이전에 직접 구현한 기본 메서드가 이미 findAll(), findAll(), findAllById()로 구현되어 있는 것을 확인할 수 있었습니다.CRUD에서도 기본 메서드가 이미 구현되어있는 것을 확인할 수 있었습니다.사실 여기에 맞추어 예제를 만든 것이라고 합니다.findByName() 만 추가한 이유는 공통으로 제공되는 메서드가 아니기 때문입니다.그런데 추가로 코드로 내부를 구현을 하지 않고 findByName() 이름 하나만으로 findByName()을 구현할 수 있는 이유는 스프링 데이터 JPA가 findBy 뒤에 Name이라는 규칙을 통해서 자동으로 JPQL을 생성해주기 때문입니다.따라서 스프링 데이터 JPA는 인터페이스를 통한 기본적인 CRUD를 제공하며, findByName(), findByEmail()처럼 메서드 이름 만으로 조회 기능 제공합니다.실무에서는 JPA와 스프링 데이터 JPA를 기본으로 사용하고, 복잡한 동적 쿼리는 Querydsl라는 라이브러리를 사용합니다. Querydsl을 사용하면 쿼리도 자바 코드로 안전하게 작성할 수 있고, 동적 쿼리도 편리하게 작성할 수 있습니다.이 조합으로 해결하기 어려운 쿼리는 JPA가 제공하는 네이티브 쿼리를 사용하거나, 앞서 학습한 스프링 JdbcTemplate를 사용합니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert 생성자가 1개인 경우 @Autowired 생략 가능이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 21 - 7.스프링 DB 접근 기술 (5)", "url": "/posts/Inflearn-spring21/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-21 01:10:00 +0900", "snippet": "JPA (Java Persistence API)이전 강의에서 순수 JDBC 에서 JDBC Template으로 변경해서 작성해야 하는 코드를 확 줄일 수 있었습니다. 하지만 아직까지 SQL은 직접 작성해야하는 단점이 있었습니다. JPA를 사용하면 SQL 쿼리도 JPA가 자동으로 처리를 해주어 개발 생산성을 크게 높일 수 있습니다.마치 이전 MemoryMemberRepository에서 했던 것처럼 객체를 메모리에 넣듯이, JPA에 넣으면 JPA가 중간에 DB에 SQL 보내고, 데이터를 DB에서 가져오고 하는 것을 모두 처리해줍니다.JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환을 할 수 있다.라이브러리 추가build.gradle 파일에 이전에 추가했던 implementation ‘org.springframework.boot:spring-boot-starter-jdbc’ 를 주석 처리하고implementation ‘org.springframework.boot:spring-boot-starter-data-jpa’ 를 추가하고 Load Gradle Changes를 눌러줍니다. 스프링 부트에 JPA 설정 추가application.properties 파일에 다음을 추가합니다.show-sql : JPA가 생성하는 SQL을 출력합니다.ddl-auto : JPA는 DB 테이블을 자동으로 생성하는 기능을 제공하는데 none 를 사용하면 해당 기능을 끄게 됩니다. none 대신 create를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해줍니다.위 설정을 마치면 External Libraries에 JPA와 hibernate가 설치됩니다.JPA는 자바 진영의 표준 인터페이스이고 구현은 여러 업체들이나 벤더들이 제공을 하는데 저희는 주로 JPA의 hibernate의 인터페이스만을 사용한다고 합니다.JPA는 객체와 ORM(Object Relational Mapping)이라는 기술입니다.여기서 ORM은 객체와 관계형 데이터베이스를 매핑한다는 뜻입니다. 매핑은 어노테이션으로 진행합니다.JPA 엔티티 매핑domain 폴더의 Member 클래스에 @Entity를 추가하여 Member를 JPA가 관리하는 Entity로 만들어 줍니다.PK(기본키) Id라서 @Id 어노테이션을 추가합니다.DB가 알아서 id를 생성해주는데 이런 것을 Identity전략이라고 합니다. 따라서 @GeneratedValue(strategy = GenerationType.IDENTITY)JPA 회원 리포지토리repository 폴더에 JpaMemberRepository 클래스를 위와 같이 생성합니다.JPA 는 EntityManager를 통해서 동작합니다. build.gradle에서 jpa 라이브러리를 받았는데 스프링 부트가 자동으로 DB와 연결된 EntityManager를 생성합니다. 저희는 그 만들어진 EntityManager 주입(injection)만 받으면 됩니다.save()이전 JdbcTemplate으로 save를 구현한 것과 JPA를 이용하여 save를 구현한 코드의 차이입니다.EntityManager가 알아서 내부적으로 모든 것을 다 처리해주기 때문에 따로 Insert, HashMap등을 사용할 필요 없이 EntityManager 하나만 사용하면 됩니다.persist는 영구 저장한다는 의미입니다.findById()EntityManager에 find라는 함수가 있습니다. 여기에 타입이랑 PK(식별자)만 넣어주면 됩니다.findByName()findByName() 함수의 경우 테이블을 대상으로 쿼리를 날리는 것이 아니라 객체를 대상으로 쿼리를 날리는 것으로 알아서 SQL로 번역됩니다.따라서 Member 엔티티를 대상으로 쿼리를 날리는데, 특이한 점은 select 뒤에가 *이나 id, name이 아닌 m 객체 자체를 조회합니다.“select m from Member as m where m.name = :name”, Member.class 같은 JPQL 이라는 쿼리를 생성해서 조회해야 합니다.Id 처럼 PK 기반이 아닌 다른 컬럼으로 조회를 하는 경우 JPQL을 작성해야 합니다.findAll()findByName() 함수의 JPQL 쿼리와 내용이 유사합니다.JPA를 사용하도록 스프링 설정 변경SpringConfig 클래스에서 JpaMemberRepository를 사용하기 위해 설정을 변경합니다. 이전에 생성자였던 dataSource는 삭제합니다.주의사항JPA 를 사용하려면 항상 트랜잭션이 필요합니다. 따라서 서비스 계층인 MemberService 클래스에 @Transactional 어노테이션을 추가합니다.테스트 실행이전에 만든 통합 테스트로 회원가입 기능만 실행한 결과입니다. JPA를 구현하면 기본적으로 Hibernate라는 오픈소스 구현체가 사용됩니다.select 쿼리 문이 나간건 validation 때문에 하나 가져오는 것 같습니다.그 후 저희가 설정하지 않은 Insert 문을 JPA가 자동으로 실행하여 회원가입을 테스트 하는 것을 확인할 수 있었습니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert 생성자가 1개인 경우 @Autowired 생략 가능이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 20 - 7.스프링 DB 접근 기술 (4)", "url": "/posts/Inflearn-spring20/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-20 02:33:00 +0900", "snippet": "스프링 JdbcTemplateJdbcTemplate은 이전에 만들었던 순수 Jdbc와 동일한 환경설정을 하면 됩니다. 스프링 JdbcTemplate라이브러리는 JDBC API에서 본 connection 같은 반복적인 코드를 대부분 제거해줍니다. 하지만 SQL은 직접 작성해야 합니다.Template이라고 부르는 이유는 디자인 패턴중에 템플릿 메서드 패턴이라는 것이 있는데 그것이 많이 포함되어서 JdbcTemplate이라고 부릅니다.JdbcTemplate 회원 리포지토리 작성jdbcTemplate는 injection을 받을 수는 없습니다.대신 이전에 datasource injection 받은 것 처럼 파라미터에 DataSource dataSource를 넣어 jdbcTemplate 생성자를 생성합니다.save() 기능 구현 SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate); jdbcInsert.withTableName(&quot;member&quot;).usingGeneratedKeyColumns(&quot;id&quot;); Map&amp;lt;String, Object&amp;gt; parameters = new HashMap&amp;lt;&amp;gt;(); parameters.put(&quot;name&quot;, member.getName());쿼리를 짤 필요 없이 바로 위 4줄로 INSERT문을 만들 수 있습니다.key를 executeAndReturnKey로 받아서 member에 넣어줍니다.위 코드에 대한 자세한 설명은 jdbcTemplate DOCUMENT에 잘 나와있습니다.아이디 조회 쿼리 작성이전에 길었던 코드를 jdbcTemplate 라이브러리를 사용하여 단 2줄에 해결할 수 있었습니다.참고로 memberRowMapper() 는 다음과 같습니다.private RowMapper&amp;lt;Member&amp;gt; memberRowMapper(){ return (rs, rowNum) -&amp;gt; { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return member; }; }member 객체를 생성해서 반환합니다.이름 조회 쿼리 작성@Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { List&amp;lt;Member&amp;gt; result = jdbcTemplate.query(&quot;select * from member where name = ?&quot;, memberRowMapper(),name); return result.stream().findAny(); }아이디 쿼리 조회에서 id만 name으로 바꿉니다.전체 조회 쿼리 작성@Override public List&amp;lt;Member&amp;gt; findAll() { return jdbcTemplate.query(&quot;select * from member&quot;, memberRowMapper()); }위 처럼 간단하게 작성할 수 있습니다.환경 설정 변경 (SpringConfig)JdbcTemplateMemberRepository;를 연결시켜 줍니다.테스트 실행만약 이전에 만든 테스트를 실행하지 않고 제대로 작동하는지 확인한다면 일일이 회원을 기입하고 DB에 연동되는 것을 확인하는 번거로운 작업을 해야합니다. 하지만 이전에 만든 테스트 케이스가 있기 때문에 통합 테스트를 먼저 실행해보도록 하겠습니다.에러 없이 잘 작동하는 것을 확인할 수 있었습니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert 생성자가 1개인 경우 @Autowired 생략 가능이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 19 - 7.스프링 DB 접근 기술 (3)", "url": "/posts/Inflearn-spring19/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-20 01:29:00 +0900", "snippet": "스프링 통합 테스트이번 시간은 이전 시간에 만든 DB와 스프링이 JDBC로 연결된 코드를 모두를 테스트 할 것입니다.이전 코드를 살펴보면, 스프링과 관련 없는 자바 코드입니다. 하지만 이전 코드는 스프링이 직접 관리해주는 코드입니다. 따라서 이번 테스트는 스프링과 연관하여 진행해보겠습니다.테스트 클래스 작성이전에 만든 MemberServiceTest 클래스를 복사하여 MemberServiceIntegrationTest로 새로운 클래스를 생성합니다.그 후 @SpringBootTest, @Transactional 을 추가합니다. @SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행합니다. @Transactional : 테스트를 실행할 때, 트랜잭션을 먼저 실행하고 DB의 데이터를 넣고 커밋을 하고 DB를 저장합니다. 그 후 롤백을 통해 반영을 시키지 않고 테스트 이전 상태로 돌려줍니다.MemoryMemberRepository()를 사용하여 메모리 객체를 이용하는 부분은 지우고 필드 주입 방식으로 @Autowired 어노테이션을 바로 달아줍니다. 테스트는 공개하는 것이 아니기 때문에 필드 주입을 해도 크게 문제가 되지 않습니다.AfterEach는 @Transactional가 있으므로 지워줍니다. 뿐만 아니라 setup(), findMembers(), findOne()도 지워줍니다.회원가입() 테스트 실행먼저 실험삼아 회원가입() 기능을 테스트 해보았습니다. 결과는 에러가 발생하는데 이유는 spring이라는 이름이 DB에 남아있는데 테스트로 가입을 시도해보았기 때문입니다.따라서 DB의 내용을 모두 지우고 다시 테스트 진행해보겠습니다. 그 전에 @Transactional를 주석 처리하고 실행해보겠습니다.테스트로 회원가입을 진행한 경우 spring이라는 이름을 가진 회원이 등록된 것을 확인할 수 있습니다.하지만 두 번 실행할 경우 spring이 메모리에 남아있기 때문에 지워줘야 합니다. 이를 전에는 AfterEach와 BeforeEach가 지워줬다면 지금은 @Transactional이 지워줍니다.즉 @Transactional이 있는 상태는 데이터가 남아있지 않아 다음 테스트에 영향을 주지 않습니다.전체 단위 테스트테스트 전체를 실행해도 에러가 발생하지 않는 것을 확인할 수 있습니다.추가먼저 이전 테스트를 단위 테스트 라고 하고 이번 테스트는 DB까지 연동하여 통합 테스트 라고합니다.스프링 자체에서 테스트 기능을 제공한다고 이전의 테스트는 필요가 없는 것은 아닙니다. 이유는 먼저 속도의 차이에서 확인할 수 있습니다.이전 스프링과 함께 통합 테스트를 하는 시간의 약 1/7로 확 줄어든 것을 확인할 수 있었습니다.또한 단위 테스트 처럼 기능 단위로 쪼개서 테스트 하는 것이 더 좋은 테스트일 확률이 높습니다. 그래서 스프링 컨테이너 없이 테스트 할 수 있도록 훈련을 해야합니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 18 - 7.스프링 DB 접근 기술 (2)", "url": "/posts/Inflearn-spring18/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-19 20:24:00 +0900", "snippet": "순수 JDBC이번 시간은 애플리케이션과 DB를 연동해서 DB에 데이터를 실제로 저장해보겠습니다. 요즘은 이런 방식으로 진행하지 않습니다.환경 설정1. build.gradle 파일에 라이브러리를 추가합니다.implementation &#39;org.springframework.boot:spring-boot-starter-jdbc&#39;runtimeOnly &#39;com.h2database:h2&#39;자바는 기본적으로 DB와 연동되기 위해서는 JDBC가 필요합니다.H2 데이터베이스와 연동되기 위해서는 h2 클라이언트가 필요합니다.2. DB 경로 설정src &amp;gt; main &amp;gt; resources &amp;gt; application.properties 파일에 다음을 추가합니다.spring.datasource.url=jdbc:h2:tcp://localhost/~/testspring.datasource.driver-class-name=org.h2.Driverspring.datasource.username=sa만약 빨간불이 뜰 경우 import가 안된 것으로, 옆에 코끼리를 눌러주면 최신화를 자동으로 해줍니다.주의사항스프링부트 2.4 부터는 spring.datasource.username=sa를 꼭 추가해야 합니다.그렇지 않으면 Wrong user name or password가 발생합니다. 또한 sa 뒤에 공백이 있으면 에러가 발생하므로 공백은 모두 없애야 합니다.API를 통한 개발이제는 JDBC, API를 통한 개발을 해보도록 하겠습니다.지금까지 회원을 저장하는 역할이나 기능은 MemberRepository가 했습니다. 그리고 저장은 MemoryMemberRepository에 저장했습니다. 하지만 지금은 DB랑 연동해서 JDBC로 저장을 진행할 것입니다.먼저 repository에 JdbcMemberRepository 클래스를 생성합니다.그 후 implements MemberRepository를 추가하고 빨간줄은 우클릭을 하여Show Context Actions &amp;gt; Implement methods &amp;gt; 4개 모두 선택 &amp;gt; OK 선택합니다.이제 하나씩 추가합니다.private final DataSource dataSource; 를 추가합니다.public JdbcMemberRepository(DataSource dataSource) { this.dataSource = dataSource; }스프링을 통해서 dataSource 을 주입 받습니다.1. save() 메소드String sql = &quot;insert into member(name) values(?)&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); pstmt.setString(1, member.getName()); pstmt.executeUpdate(); rs = pstmt.getGeneratedKeys(); if (rs.next()) { member.setId(rs.getLong(1)); } else { throw new SQLException(&quot;id 조회 실패&quot;); } return member; } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } ResultSet rs : 결과를 만드는 것입니다. getConnection() : DB 와의 connection을 가져옵니다. RETURN_GENERATED_KEYS : DB에 insert를 하면 1, 2 같은 연속적인 순서를 얻을 수 있게 해줍니다. setString(1, member.getName());: 1은 values(?) 의 ?에 매칭이 됩니다. 그 후 member.getName() 으로 값을 넣습니다. pstmt.executeUpdate(); : DB에 실제 쿼리를 전달합니다. rs = pstmt.getGeneratedKeys() : DB가 방금 생성한 키를 반환합니다. RETURN_GENERATED_KEYS와 매칭되어 사용할 수 있습니다. rs.next() : rs(resultSet)이 순서 값을 가지고 있는데 next에 값이 있으면 값을 꺼내줍니다. close : 복잡하다 정도만 알고 있으면 됩니다. 요즘은 이렇게까지 디테일하게 구현을 안해도 된다고 합니다.2. findById() 메소드@Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { String sql = &quot;select * from member where id = ?&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); pstmt.setLong(1, id); rs = pstmt.executeQuery(); if(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return Optional.of(member); } else { return Optional.empty(); } } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } }findById() 조회 기능입니다. 크게 특별한 건 없고 rs.next() 가 값이 있으면 값을 member에 넣어줍니다.3. findByName() 메소드@Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { String sql = &quot;select * from member where name = ?&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); pstmt.setString(1, name); rs = pstmt.executeQuery(); if(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return Optional.of(member); } return Optional.empty(); } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } }4. findAll() 메소드@Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { String sql = &quot;select * from member where name = ?&quot;; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql); pstmt.setString(1, name); rs = pstmt.executeQuery(); if(rs.next()) { Member member = new Member(); member.setId(rs.getLong(&quot;id&quot;)); member.setName(rs.getString(&quot;name&quot;)); return Optional.of(member); } return Optional.empty(); } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } }전제조회 기능을 하는 findAll() 메소드입니다. List로 member를 members에 담아서 반환합니다.5. 기타 메소드순수 JDBC에 필요한 기타 메소드입니다. DatasourceUtils를 이용해서 Connection 메소드와 close메소드를 구현합니다. 하지만 기타 메소드 뿐만 아니라 위 코드는 쓸 일이 거의 없기 때문에 참고로 알아두시면 좋습니다.Configuration 변경위 코드만으로는 실행이 불가능합니다.추가로 service 패키지의 SpringConfig 클래스를 변경합니다.DataSource는 데이터베이스 커넥션을 획득할 때 사용하는 객체입니다.스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어줍니다. 그래서 DI를 받을 수 있습니다.memberRepository 메소드의 반환 값을 new JdbcMemberRepository()로 변경합니다.dataSource를 DataSource형으로 선언하고 SpringConfig(DataSource dataSource) 메소드에 dataSource 의존성을 추가합니다.스프링이 DB까지 관리할 수 있게 @Autowired를 추가하여 스프링 빈으로 만들어 줍니다.여기서 중요한 점은 main안에 있는 다른 코드는 수정하지 않고 SpringConfig 파일 하나만 수정하였습니다.스프링 실행 결과위 설정들을 모두 마치고 스프링을 실행했습니다. 주의할 점은 H2 DB가 실행되는 상태에서 스프링을 실행해야 합니다.먼저 H2 DB의 상태를 바로 웹 회원 목록에서 확인할 수 있었습니다.그리고 웹에서 jpa 라는 이름을 추가하여 회원가입 시킨 후, 회원 목록과, H2 콘솔에서 확인한 결과입니다. 모두 잘 작동하는 것을 확인할 수 있었습니다.데이터를 DB에 저장하였기 때문에 스프링 서버를 다시 실행해도 데이터가 안전하게 저장된 것을 확인할 수 있습니다.정리왜 스프링을 사용하는지 이번에 자세하게 확인할 수 있었습니다.객체지향적 설계의 장점 중 하나인 다형성이 이번 실습에 잘 드러나 있는데 인터페이스인 MemberRepository를 사이에 두고 구현체인 MemoryMemberRepository와 JdbcMemberRepository를 쉽게 갈아 탈 수 있습니다. 스프링은 이 장점을 매우 편리하게 사용할 수 있도록 스프링 컨테이너가 지원을 해줍니다.과거의 경우 의존성을 모두 일일이 수정해야 했습니다. 가령 MemberService가 MemoryMemberRepository를 의존하는 것에서 JdbcMemberRepository를 의존하는 것으로 코드를 수정해야하는 번거로움이 있었습니다.이번 실습의 경우, MemberService만 있어서 간단하게 실행해볼 수 있었지만 실제 웹이나 앱을 만들 경우 OrderService, QnAService, AdService 등 여러가지 기능이 생길 경우 모두 수정해야 합니다.하지만 지금은 스프링 부트의 존재로 애플리케이션를 조립하는 어셈블리(SpringConfig)부분만 수정하면 되어서 매우 간편하게 수정 및 개발을 진행할 수 있습니다. 개방 폐쇠의 원칙(OCP, Open-Closed Principle)확장에는 열려있고, 수정, 변경에는 닫혀있다 라는 말로, 구현체 등을 여러 개 붙이는 확장에는 열려있고 그 구현체 내부를 수정, 변경은 닫혀있다는 스프링의 장점 중 하나입니다. 스프링의 DI (Dependencies Injection)을 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현클래스를 변경할 수 있다. 즉 저는 Bean으로 등록만 했고 나머지는 스프링이 알아서 의존성을 주입해주어 의존관계를 알아서 설정해주었습니다. Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 17 - 7.스프링 DB 접근 기술 (1)", "url": "/posts/Inflearn-spring17/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-19 19:30:00 +0900", "snippet": "이전 시간은 임시 데이터를 메모리에 저장을 했다면 지금부터는 간단한 H2라는 데이터베이스를 설치하여 이곳에 데이터를 저장하고 꺼내오는 방식을 스프링에 적용시켜보도록 할 것입니다.H2 데이터베이스 설치 H2 데이터베이스 : 개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공합니다.(https://www.h2database.com/html/download-archive.html)에서 1.4.200 버전을 설치합니다. 저는 windows10 이므로 따른 설정은 하지 않았습니다.실행파일을 바로 실행하면 H2 Console 이라는 실행파일이 깔리는데 이 파일을 실행하면 H2 데이터베이스 설정창이 브라우저에 띄어집니다.주소는 자동 설정된 아이피를 localhost 로 바꿔줍니다. 데이터베이스 파일을 생성할 때, JDBC URL을 최초에는 jdbc:h2:~/test 로 설정하고, 연결을 클릭합니다.그 후, jdbc:h2:tcp://localhost/~/test 로 변경합니다. 이렇게 변경해야 여러 곳에서 H2데이터베이스 접근이 가능합니다.뒤로가기는 H2 왼쪽 상단 연결끊기 버튼을 누르면 가능합니다.1.테이블 생성하기create table member(id bigint generated by default as identity,name varchar(255),primary key (id));위와 같이 코드를 작성하고 실행을 하여 member라는 이름의 테이블을 생성합니다. bigint : java에서 Long 이지만 SQL에서는 bigint 형을 선언합니다. generated by default as identity : DB에 null 값이 들어오면 알아서 id 값을 자동으로 채워주는 기능을 수행합니다.위와 같이 spring 이라는 이름을 가진 데이터를 member 데이터베이스에 삽입하였습니다.spring이라는 이름을 가진 data가 들어간 것을 확인할 수 있습니다. ID는 자동으로 1이 들어가는 것도 확인할 수 있습니다.spring2 라는 이름을 가진 데이터도 추가로 반영한 결과입니다.추가src 디렉토리 밖에 sql 디렉토리를 만들고 ddl.sql 파일을 만들서 table을 함께 관리할 수 있게 했습니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 16 - 6.회원 관리 예제 - 웹 MVC 개발", "url": "/posts/Inflearn-spring16/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-14 19:45:00 +0900", "snippet": "회원 웹 기능이전시간에 memberController를 만들어 의존관계를 설정해놓은 것을 바탕으로 회원관리 예제를 웹 MVC로 개발 해볼 것입니다. memberController를 통해서 회원을 등록하고 조회 하는 것을 만들어 보겠습니다.1. 홈 화면 추가@Controllerpublic class HomeController { @GetMapping(&quot;/&quot;) public String home(){ return &quot;home&quot;; }}Controller 패키지에 HomeController를 만들고 @Controller를 추가합니다.이를 통해 http://127.0.0.1:8080을 접속하면 (“/”) 로 인해 가장 먼저 뜨는 화면을 제어하는 코드입니다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Hello Spring&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;회원 기능&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;a href=&quot;/members/new&quot;&amp;gt;회원 가입&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;/members&quot;&amp;gt;회원 목록&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;return “home”을 통해 templates에서 home.html 파일을 서비스 합니다.실행하면 다음과 같습니다.더 깊게 알아보기Q. 예전에는 index.html가 먼저 브라우저에 서비스 되었는데 이번에는 home.html 이 먼저 서비스 되었습니다. 이유는 무엇일까요?A. 스프링 개발 기초 부분의 정적 컨텐츠 편에서 다루었던 내용입니다. 웹 브라우저에서 요청이 먼저 들어오면 스프링은 스프링 컨테이너 부터 스캔하여 컨트롤러의 등록 여부를 판단합니다. 등록되어있지 않으면 그 다음 순서로 static파일을 찾습니다.즉, home.html이 컨테이너에 등록되어있어 index.html 보다 먼저 서비스 되는 것입니다.&amp;lt;p&amp;gt; &amp;lt;a href=&quot;/members/new&quot;&amp;gt;회원 가입&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;/members&quot;&amp;gt;회원 목록&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;home.html을 자세히 살펴보면 위와 같이 &amp;lt;a&amp;gt; 태그로 링크가 달려있는 것을 확인할 수 있습니다.이를 통해 글씨를 클릭하면 다른 페이지로 이동합니다.2. 등록MemberController 클래스에 2가지 메소드를 추가합니다. 홈 화면에서 클릭시 이동하는 페이지입니다.templates 디렉토리에 members디렉토리를 만들고 createMemberForm.html파일을 생성하고 코드는 다음과 같습니다.&amp;lt;!-- createMemberForm.html --&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;form action=&quot;/members/new&quot; method=&quot;post&quot;&amp;gt; &amp;lt;div class=&quot;form-group&quot;&amp;gt; &amp;lt;label for=&quot;name&quot;&amp;gt;이름&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; placeholder=&quot;이름을 입력하세요&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button type=&quot;submit&quot;&amp;gt;등록&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;위 코드를 간략하게 설명드리면, &amp;lt;form action=&quot;/members/new&quot; method=&quot;post&quot;&amp;gt;&amp;lt;form&amp;gt; 태그의 action 속성은 form 데이터(form data)를 서버로 보낼 때 해당 데이터가 도착할 URL을 명시합니다. 그래서 http://localhost:8080/members/new로 데이터를 보냅니다.&amp;lt;form&amp;gt; 태그의 method 속성은 폼을 서버에 전송할 http 메소드를 지정하는데 크게 GET과 POST 방식이 있습니다. POST는 클라이언트에서 서버로 데이터를 보낼때, GET은 클라이언트가 서버에서 데이터를 가져올 때 사용합니다. name=”name”여기서 name이 서버로 넘어갈 때 key역할을 합니다. placeholder아무것도 입력이 안되었을 때 보여지는 글씨입니다.스프링을 실행시킨 화면입니다. 이름을 입력하면 {이름: osnim}이 키-값 쌍으로 전달됩니다.회원 등록하는 컨트롤입니다. controller 패키지에 MemberForm 클래스를 만들고 MemberForm 안에 변수 name과 getter, setter 를 생성합니다. MemberForm 클래스 name은 createMemberForm.html의 name과 매칭이 됩니다.MemberController 클래스에 create 메서드를 추가합니다. form 으로 새로운 회원 정보를 받아 객체를 생성하고 이름을 set하고 redirect를 이용해서 홈 화면으로 보냅니다.지금은 이름을 기입하고 등록을 눌러도 회원 목록을 볼 수 없지만 나중에 회원 목록 기능을 추가하면 확인이 가능합니다.복습 - MemberService의 join 메서드그 후 이전에 만든 join 메서드로 이름 중복 확인 후 save 합니다.회원 가입 동작 원리method가 post 방식이라서 데이터를 서버로 전송할 때 사용합니다. 따라서 “members/new”라는 URL은 같지만 GET, POST에 따라 다르게 맵핑할 수 있습니다.참고로 Get 방식은 URL을 직접 쳐서 들어가는 방식으로 조회할 때 주로 사용합니다.먼저 createMemberForm.html의 name이 MemberForm에 들어갈 때 스프링이 알아서 name이라는 key를 확인하고 @PostMapping어노테이션을 확인하고 MemberForm을 받아 저장합니다.3. 조회회원 관리 기능중에서 조회 기능을 구현할 것입니다. MemberController 클래스에 다음을 추가합니다.@GetMapping(&quot;/members&quot;) public String list(Model model){ List&amp;lt;Member&amp;gt; members = memberService.findMembers(); model.addAttribute(&quot;members&quot;, members); return &quot;members/memberList&quot;; }이전에 했던 것과 비슷하게 model.addAttribute를 이용해서 작성합니다.&amp;lt;!--memberList.html--&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;이름&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr th:each=&quot;member : ${members}&quot;&amp;gt; &amp;lt;td th:text=&quot;${member.id}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td th:text=&quot;${member.name}&quot;&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;회원 목록 버튼 클릭시 이동되는 페이지의 html 코드입니다. 여기서는 thymeleaf가 동작합니다. 위 코드를 타임리프가 렌더링해서 웹 브라우저에 서비스 합니다.${members} 에서 $ 는 model 안에 있는 값을 꺼내는 역할을 합니다.th는 thymeleaf 문법을 나타내며, each는 loop을 의미합니다. ${members}”에서 객체를 꺼내서 member에 담고 그 member에 속한 id와 name을 출력합니다.스프링을 실행하고 이름을 기입하여 회원 목록을 확인하니 저장된 이름들이 출력되는 것을 확인할 수 있었습니다.페이지 소스 코드를 확인하니 memberList.html와 달리 thymeleaf로 인해 렌더링 된 소스코드가 출력되는 것을 확인할 수 있었습니다.데이터가 DB가 아닌 메모리에 있기 때문에 스프링을 재시작하면 회원 목록들이 모두 사라지게 됩니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + / getter, setter 단축키 : Alt + Insert이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 15 - 5.스프링 빈과 의존관계 (2)", "url": "/posts/Inflearn-spring15/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-13 23:56:00 +0900", "snippet": "자바 코드로 직접 스프링 빈 등록하기이전시간에 등록한 @Service, @Repository, @Autowired를 모두 지우고 진행합니다.Hello.Hellospring 패키지에 SpringConfig라는 클래스를 생성하고 @Configuration를 추가합니다.그 후 @Bean 어노테이션과 함께 memberService 를 추가합니다. @Bean이 memberService를 컨테이너에 저장한다는 의미입니다.memberService 외에 MemoryMemberRepository 객체를 반환하는 memberRepository 메서드를 생성하고 @Bean을 추가합니다.MemberService()는 memberRepository에 의존하기 때문에 MemberService 객체를 반환할 때 파라미터로 memberRepository() 메서드를 넣어줍니다.위 과정을 마치면 의존관계 설정이 완료됩니다.DI의 3가지 방법 필드 주입 필드 주입이란 MemberController 생성자 부분을 모두 지우고 필드에 @Autowired를 직접 입력하는 방법입니다. 필드 주입 방식은 변환시킬수 없기 때문에 크게 추천하는 방식은 아닙니다. setter 주입 Generator에서 MemberService setter를 생성하고 @Autowired를 추가합니다. setter를 통해 의존관계가 주입됩니다. setter 주입은 누군가가 MemberController를 호출했을 때 public으로 열려있어야 합니다. 그런데 public이라는 접근 지정자를 사용해서 중간에 다른 곳에서 호출되면 문제가 발생할 수도 있기 때문에 권장하는 방법은 아닙니다. 생성자 주입생성자 주입이란 MemberController에서 생성자를 통해서 memberService가 MemberController에 주입이 됩니다. 의존관계가 프로그램 동작중에 동적으로 변하는 경우는 없으므로 위 3가지 방법중에서 생성자 주입 방식을 권장합니다. 자바 코드로 직접 스프링 빈 등록하기의 장점상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록이 가능합니다.클래스의 의존관계에서 볼수 있듯이 지금은 DB가 없고 DB와 연결되어있지 않아서 가상으로 구현체(MemoryMemberRepository)를 생성하고 후에 교체하는 방식으로 스프링을 진행하고 있습니다.하지만 나중에는 MemoryMemberRepository 다른 DB나 리포지토리로 바꿀 경우 기존의 코드는 거의 수정하지 않고 교체할 수 있습니다.예를 들어 SpringConfig 에서 MemoryMemberRepository()를 DBMemberRepository()로 변경하기만 하면 됩니다.참고 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용합니다. @Autowired 를 통한 DI는 helloConroller , memberService 등과 같이 스프링이 관리하는객체에서만 동작합니다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않습니다. Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + /이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 14 - 5.스프링 빈과 의존관계 (1)", "url": "/posts/Inflearn-spring14/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-13 16:08:00 +0900", "snippet": "컴포넌트 스캔과 자동 의존관계 설정이전까지는 memberservice랑 리포지토리를 만들었습니다. 그리고 member객체를 만들어 memberservice를 통해서 가입을 진행시키고 리포지토리에 저장을 시키고 가져오는 로직을 구성하고 테스트까지 진행해봤습니다.이번시간에는 화면에 나타내기 위해 Controller랑 BeutifulSoup가 필요합니다. Controller랑 BeutifulSoup를 사용하기 위해서는 MemberController는 MemberService를 통해서 회원가입하고 MemberService를 통해서 조회할 수 있어야 합니다.이러한 관계를MemberService가 MemberController를 의존한다고 표현하고 둘은 의존관계에 있다고 표현합니다.스프링 빈 (Spring Bean)스프링 빈: 스프링 컨테이너가 관리하는 자바 객체로 스프링에서는 객체를 빈이라고 표현합니다.@의 기능 : 스프링 부트가 실행되면 스프링 컨테이너에 MemberController 객체를 생성하고 컨테이너에 넣어서 스프링이 관리를 합니다. 이러한 것을 스프링 빈이 관리된다고 표현합니다.MemberController 생성Controller 패키지에 MemberController라는 클래스를 생성하고 @Controller라는 어노테이션을 달아줍니다.MemberController에서 MemberService 객체를 new로 생성해서 MemberService를 사용할 수도 있지만 스프링을 사용하면 스프링 컨테이너에 등록하고 컨테이너에서 가져와서 사용해야 합니다.이유는 Memberservice 객체는 MemberController 뿐만 아니라 다른 Controller에서 MemberService를 가져다 써야하는데 MemberService의 기능은 특별하지 않습니다. 그래서 Controller별로 구분지어서 새로 만들 필요가 없이 하나의 MemberService를 컨테이너에 등록해서 사용하는 것이 훨씬 효율적입니다.컨테이너에 등록하는 방법은 다음과 같습니다.생성자를 이용해서 memberService 객체를 선언하고 생성자에 @Autowired 어노테이션을 추가합니다. 이렇게 되면 생성자에 있는 @Autowired로 인해 스프링이 memberService를 컨테이너에 있는 memberService를 가져다가 연결을 시켜줍니다.@Autowired 에러하지만 이렇게 에러가 발생하는 것을 확인할 수 있습니다.이유는 아직 MemberService가 컨테이너에 등록되어 있지 않기 때문입니다.위는 MemberService 클래스 입니다. 위에 아무런 @(어노테이션)이 없어서 MemberService의 @Autowired의 에러가 발생한 것입니다. 이를 고치기 위해 @Service를 MemberService 클래스 위에 추가합니다.추가로 MemoryMemberRepository 클래스로 이동해서 @Repository를 추가합니다.지금 추가한 어노테이션은 @Controller, @Controller, @Repository 총 3개입니다. 컨트롤러를 통해서 외부요청을 받고, 서비스에서 비즈니스 로직을 만들고, 리포지토리에서 데이터를 저장하는 가장 정형화된 패턴으로 이러한 형식으로 자주 개발을 합니다.DI(Dependency Injection), 의존성 주입스프링의 가장 큰 장점중 하나인 의존성 주입입니다. MemberController를 생성할 때, 스프링 빈에 등록되어있는 MemberService 객체를 MemberController에 파라미터로 직접 넣어줍니다. 이를 의존성 주입이라고 하는데 MemberController는 가만히 있고 외부(스프링)에서 의존관계를 넣어주는 것입니다.memberService는 memberRepository가 필요하기 때문에 MemberService 클래스에 가서 memberService생성자에 @Autowired를 추가합니다.또한 memberService는 memberRepository가 필요하기 때문에 memberRepository를 파라미터로 넣어줍니다.main 매서드를 실행하면 에러가 발생하지 않는 것을 확인할 수 있습니다.스프링 빈을 등록하는 2가지 방법 컴포넌트 스캔과 자동 의존관계 설정 어노테이션을 이용해서 @Controller, @Service, @Repository를 추가한 것이 컴포넌트 스캔 방식입니다. 위 그림은 @Controller, @Controller, @Repository를 차례로 확인한 것입니다. 이를 통해 모두 @Component 어노테이션이 자동으로 있는 것을 확인할 수 있습니다. 이를 통해 스프링이 시작하고 @Component 가 있는 것을 스캔해서 @Component가 있는 객체를 생성해서 컨테이너에 저장을 시킵니다.의존 관계는 @Autowired을 이용해 자동으로 연결시켜 줍니다. 자바 코드로 직접 스프링 빈 등록하기 다음시간에 자세히 다뤄 볼 것입니다. 주의사항 main 메서드가 있는 Hello.Hellospring 패키지 안에 컴포넌트만 스캔하여 스프링 빈에 등록합니다.Hello.Hellospring 패키지 밖에서 선언된 컴포넌트들은 스캔할 수 없습니다. 스프링은 컨테이너에 스프링 빈을 등록할 때, 싱글톤을 기본으로 하여 등록합니다. 싱글톤이란 딱 한 개만 등록한다는 말로 위에서는 helloController는 딱 한개만 등록한다는 의미입니다. 유일하게 한 개만 등록해서 공유한다는 말로 만약 memberService와 OrderService(가정)가 모두 memberRepository를 의존한다면 모두에게 같은 memberRepository 인스턴스를 반환합니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + /이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "백준 18405 경쟁적 전염 (python)", "url": "/posts/BOJ-18405/", "categories": "BFS", "tags": "BOJ, BFS, 18405", "date": "2022-03-10 21:15:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/18405나의 접근법위 문제는 이것이 코딩테스트다 with 파이썬 에 수록된 문제입니다. 먼저 답을 읽지 않고 제 스스로 풀어보려고 노력했습니다.바이러스의 위치를 x,y좌표로 기억하여 번호 마다 리스트에 저장하였습니다.그리고 시간 S 만큼 반복하여 바이러스를 퍼뜨렸습니다.일반 케이스 말고 특이 케이스도 생각해봤습니다. 만약 1번 바이러스가 2번 나오면 어떡하지? 만약 1~K번의 바이러스가 연속으로 나오지 않고 랜덤으로 나오면 어떡하지? 저는 위와 같은 경우의 수도 고려하며 풀려고 노력했습니다. 첫번째 풀이법import sysfrom collections import dequedef BFS(virus, virusPositions): for i in range(len(virusPositions[virus])): a, b = virusPositions[virus].pop(0) for j in range(4): nx = a + dx[j] ny = b + dy[j] if nx &amp;gt;= 0 and nx &amp;lt; N and ny &amp;gt;= 0 and ny &amp;lt; N: if virusGraph[nx][ny] == 0: virusGraph[nx][ny] = virus virusPositions[virus].append([nx, ny])virusGraph = []N, K = map(int, sys.stdin.readline().split())for i in range(N): virusGraph.append(list(map(int, sys.stdin.readline().split())))virusPositions = [[] for _ in range(N+1)]for i in range(N): for j in range(N): if virusGraph[i][j] != 0: virusPositions[virusGraph[i][j]].append([i, j])S, X, Y = map(int, sys.stdin.readline().split())dx = [1, -1, 0, 0]dy = [0, 0, 1, -1]for i in range(S): for virusNum in range(1, K+1): if not virusPositions[virusNum]: continue BFS(virusNum, virusPositions)print(virusGraph[X-1][Y-1])위 코드는 제가 처음으로 제출한 것입니다. 예시는 맞았지만 IndexError가 발생했습니다. print()로 로그를 찍어가며 문제점을 몇시간 동안이나 찾았지만 결국 잡아 내지 못했습니다. 그래서 구글링과 블로그를 찾아가며 저와 비슷하게 IndexError가 발생한 경우를 찾아보았습니다. 하지만 IndexError는 거의 찾아볼 수 없었고 저는 백준에서 게시판이라는 곳에서 18405번 문제 중 IndexError에 대한 글을 남긴 내용을 찾아봤습니다.딱 1개 있었지만 답변은 없었습니다..하는 수 없이 저는 제 코드를 남기고 질문을 남겼습니다. 질문의 주소는 다음과 같습니다.https://www.acmicpc.net/board/view/85776#comment-139171몇 시간 안되어 nasoob114 님께서 바로 답변을 달아주셨고 반례를 들어주며 왜 틀렸는지도 알려주셨습니다.위 답변을 통해 저는 코드를 바로잡을 수 있었고 반례도 통과할 수 있었습니다. nasoob114 님께 정말 감사드린다고 또 한 번 전하고 싶습니다. 덕분에 며칠 씨름해도 못풀 문제를 단숨에 해결할 수 있었습니다.그 반례는 다음과 같습니다.2 33 01 20 1 1K가 항상 N보다 작거나 같을 경우의 수만 생각했습니다. 하지만 K가 N보다 큰 경우는 생각하지 못했습니다.이 경우 virusPositions[virusGraph[i][j]].append([i, j]) 에서 index error 가 발생합니다. virusPositions[virusGraph[i][j]]에서 K가 N 보다 클 수도 있기 때문에 인덱스 에러가 발생하는 것이었습니다.위 코드를 수정하여 2번째 코드를 작성하고 제출하였습니다.두번째 제출 코드import sysfrom collections import dequedef BFS(virus, a, b, s): #for i in range(len(virusPositions[virus])): for j in range(4): nx = a + dx[j] ny = b + dy[j] if nx &amp;gt;= 0 and nx &amp;lt; N and ny &amp;gt;= 0 and ny &amp;lt; N: if virusGraph[nx][ny] == 0: virusGraph[nx][ny] = virus virusPositions.append([virus, nx, ny, s+1])virusGraph = []N, K = map(int, sys.stdin.readline().split())for i in range(N): virusGraph.append(list(map(int, sys.stdin.readline().split())))virusPositions = []for i in range(N): for j in range(N): if virusGraph[i][j] != 0: #바이러스 번호, 바이러스 좌표, 시간 virusPositions.append([virusGraph[i][j], i, j, 0])virusPositions.sort(key=lambda x: x[0])virusPositions = deque(virusPositions)S, X, Y = map(int, sys.stdin.readline().split())dx = [1, -1, 0, 0]dy = [0, 0, 1, -1]#S초만큼만 반복for i in range(S): for j in range(1, K+1): virusNum, x, y, s = virusPositions.popleft() BFS(virusNum, x, y, s)print(virusGraph[X-1][Y-1])바이러스 번호를 인덱스로 사용하여 위치를 저장하지 않고, append()를 사용해서 번호와 위치, 그리고 초 까지 한번에 입력시키고 정렬하였습니다. 리스트를 큐로 사용하여 가장 먼저 들어간건 pop(0)로 가장 먼저 꺼내는 방식을 이용하여 문제를 해결했습니다.하지만 이 경우에도 IndexError가 발생하였습니다. 솔직히 이 때 그냥 접고 책이랑 똑같이 제출하고 싶었습니다. 하지만 이 경우 제가 놓친 무언가가 있을 것 같다고 생각하고 책에나온 풀이와 제 코드를 다시 한 번 코드를 분석했습니다.차이점은 쉽게 찾을 수 있었습니다. 저는 for i in range(S)로 입력된 시간만큼 반복문을 실행하며 virusPositions에서 데이터를 가져오는 방식이었습니다.그런데 이경우 아래와 같은 예시처럼2 43 40 210 1 11초만에 모든 그래프에 바이러스가 퍼져 더 이상 virusPositions 정보가 없는데 계속 popleft()해서 IndexError가 발생하는 것이었습니다.그래서 저의 풀이는 완전 틀렸다는 것을 깨닫고서야 책과 비슷하게 답을 작성했습니다. 하지만 책을 베끼진 않았고 왜 그렇게 풀었는지 그제서야 이해할 수 있었습니다.아래는 마지막으로 제가 제출한 코드입니다.세번째 제출 코드 (최종)import sysfrom collections import dequedef BFS(virus, a, b, s): for j in range(4): nx = a + dx[j] ny = b + dy[j] if nx &amp;gt;= 0 and nx &amp;lt; N and ny &amp;gt;= 0 and ny &amp;lt; N: if virusGraph[nx][ny] == 0: virusGraph[nx][ny] = virus virusPositions.append([virus, nx, ny, s+1])virusGraph = []N, K = map(int, sys.stdin.readline().split())for i in range(N): virusGraph.append(list(map(int, sys.stdin.readline().split())))virusPositions = []for i in range(N): for j in range(N): if virusGraph[i][j] != 0: #바이러스 번호, 바이러스 좌표, 시간 virusPositions.append([virusGraph[i][j], i, j, 0])virusPositions.sort(key=lambda x: x[0])virusPositions = deque(virusPositions)S, X, Y = map(int, sys.stdin.readline().split())dx = [1, -1, 0, 0]dy = [0, 0, 1, -1]#S초만큼만 반복 =&amp;gt; 이렇게 하면 10 초가 넘어가면 pop이 비어있음while virusPositions: if virusGraph[X-1][Y-1] != 0: break virusNum, x, y, s = virusPositions.popleft() if s == S: break BFS(virusNum, x, y, s)print(virusGraph[X-1][Y-1])백준 결과백준 결과입니다. 10번만에 정답을 맞을 수 있었습니다. 출력 초과는 제가 log를 찍기위해 print함수를 중간중간에 넣어놓았는데 그걸 지우지 못하고 바로 제출해서 에러가 난 경우로 실제는 8번 만에 맞았습니다.계속 IndexError가 뜰 때마다 세상이 저를 속이는 것 같았습니다. 하지만 문제를 다 맞추고 이제서야 돌이켜 보니 결국 문제는 제 스스로에게 있었습니다.후기 및 다짐백준이나 코테 문제는 대부분 모범 답안과 문제에 딱 적용되는 몇 가지 알고리즘과 코드 디테일이 정해져 있는 것 같습니다. 하지만 저는 일단 문제를 제스스로 풀어보고 안풀리면 답을 보는 과정을 들이고 있습니다.제가 알고리즘 능력을 기르기 위해 백준 문제를 푼지 2달 조금 안되는데 벌써부터 답을 보고 클린코드와 모법답안과 같은 코드를 짜는 것은 요행을 바라는 것 같아서 지금은 시간이 매우 많이 걸리더라도 답을 보지 않고 먼저 문제푸는 힘들 기르려고 노력하고 있습니다.그런데 오늘 이 문제하나 푸는데 시간을 다 보냈기 때문에 꼬박 하루 걸렸습니다. 아직은 실력이 많이 부족하여 시간대비 문제푸는 양이 너무 적은 것 같습니다.이렇게 까지 고생을 하며 18405번 문제를 풀었는데도 불구하고 정답이라고 출력되었을때 그렇게 기쁘지 않았습니다. 순수하게 제 실력 100%로 풀지 못해서 아쉬움이 커서 그런 것 같습니다.하지만 왜 틀렸는지 어디가 문제였는지 자세하게 알고 넘어가서 그부분은 하나로 이 시간들이 매우 아깝지는 않았습니다.다음 문제를 풀 때는 에러가 발생하더라도 꼭 문제의 원인을 스스로 찾아 해결해보도록 하겠습니다." }, { "title": "백준 14502 연구소 (python)", "url": "/posts/BOJ-14502/", "categories": "BFS/DFS", "tags": "BOJ, BFS/DFS, 14502", "date": "2022-03-09 19:41:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/14502깊은 복사와 얕은 복사파이썬에서는 리스트를 크게 얕은 복사와 깊은 복사 2가지로 복사하고 있습니다.얕은 복사 객체의 주소값을 복사하는 경우입니다. 대입 연산자 (‘=’) 를 사용해서 리스트를 다른 리스트에 대입하는 방식입니다. 변형(mutable) 객체는 복사한 객체의 내용을 변경하면 원본 리스트의 내용도 변합니다 불변형(immutable) 객체는 복사한 객체의 내용을 변경해도 원본에는 영향이 없습니다.깊은 복사 객체의 데이터만을 복사하는 경우입니다. copy 모듈의 copy() ,deepcopy() 함수를 사용합니다. 1차원 리스트는 copy()를 사용하고 2차원 이상의 배열은 deepcopy() 함수를 사용합니다.virusGraph = copy.deepcopy(virus_BFS(j[0], j[1], tempGraph)) list slicing 방식 [:] 입니다. list slicing이 copy 모듈을 사용하는 것보다 빠릅니다.나의 접근법위 문제는 이것이 코딩테스트다 with 파이썬 에 수록된 문제입니다. 저는 접근하는 방법만 보고 문제를 풀어보았습니다.위 문제는 지도의 최대 사이즈가 8x8로 칸막이 3개를 설치하는 방법은 최대 64C3 = 41664 입니다.따라서 저는 그래프의 정보를 입력받을 때 ‘0’ 의 좌표를 zeroLocate 리스트에 저장시키고 itertools 패키지의 combinations 모듈을 활용해서 64C3의 경우의 수 마다 ‘0’의 위치에 벽을 세웠습니다. 그 후 바이러스의 위치를 BFS로 퍼뜨려 남은 ‘0’의 개수를 세는 방식으로 풀었습니다.첫번째 제출 코드다음은 제 첫번째 코드입니다.import sysfrom collections import dequefrom itertools import combinationsimport copyN, M = map(int, sys.stdin.readline().split())# 벽 세우고 virus가 퍼진 후 그래프def virus_BFS(x, y, tempGraph): queue = deque() queue.append([x, y]) tempGraph[x][y] = 2 # 상 하 좌 우 dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] while queue: v = queue.popleft() for i in range(4): nx = v[0] + dx[i] ny = v[1] + dy[i] if nx &amp;gt;= 0 and nx &amp;lt; N and ny &amp;gt;= 0 and ny &amp;lt;M: if tempGraph[nx][ny] == 0: tempGraph[nx][ny] = 2 queue.append([nx, ny]) return tempGraphgraph = []zeroLocate = [] #0의 좌표를 저장한 리스트virusLocate = [] # 바이러스의 위치를 저장한 리스트virusGraph = [] # 바이러스가 퍼진 그래프tempGraph = [] # 그래프의 내용을 변경하기 위한 임시 그래프combinationsZeroLocate = [] #0의 좌표 중 3개 뽑는 경우의 수를 저장한 리스트result = 0 # 최종 안전 영역for i in range(N): graph.append(list(map(int, sys.stdin.readline().split()))) for j in range(M): if graph[i][j] == 0: zeroLocate.append([i, j]) elif graph[i][j] == 2: virusLocate.append([i, j])virusGraph = copy.deepcopy(graph)combinationsZeroLocate = (list(combinations(zeroLocate, 3)))for i in combinationsZeroLocate: temp = 0 tempGraph = copy.deepcopy(graph) tempGraph[i[0][0]][i[0][1]] = 1 tempGraph[i[1][0]][i[1][1]] = 1 tempGraph[i[2][0]][i[2][1]] = 1 for j in virusLocate: virusGraph = copy.deepcopy(virus_BFS(j[0], j[1], tempGraph)) for j in virusGraph: temp += j.count(0) result = max(temp, result)print(result)인접행렬로 인한 시간복잡도 :O(8^2)8x8 크기중에서 3개 뽑는 경우의 수: (8x8) C 364C3 * O(8*2) =&amp;gt; 약 8^58^5 &amp;lt; 10^2 = 100,000 이라서 시간초과가 안 뜰줄 알고 이렇게 풀이했습니다. 하지만 백준에서 python3로 제출했을 경우 시간초과가 발생했습니다. 그런데 pypy3로 제출한 경우에는 맞았습니다.제가 간과 했던 것이 저는 지도를 복사하기 위해 deepcopy라는 함수를 사용했는데 deepcopy의 시간복잡도는 계산하지 않았습니다.deepcopy 부분을 list slicing [:]으로 바꾸어 주었더니 python3 로 제출했을때도 맞을 수 있었습니다.두번째 제출 코드deepcopy 부분만 다음과 같이 수정하고 다시 제출하였습니다.import sysfrom collections import dequefrom itertools import combinationsimport copyN, M = map(int, sys.stdin.readline().split())# 벽 세우고 virus가 퍼진 후 그래프def virus_BFS(x, y, tempGraph): queue = deque() queue.append([x, y]) tempGraph[x][y] = 2 # 상 하 좌 우 dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] while queue: v = queue.popleft() for i in range(4): nx = v[0] + dx[i] ny = v[1] + dy[i] if nx &amp;gt;= 0 and nx &amp;lt; N and ny &amp;gt;= 0 and ny &amp;lt;M: if tempGraph[nx][ny] == 0: tempGraph[nx][ny] = 2 queue.append([nx, ny]) return tempGraphgraph = []zeroLocate = [] #0의 좌표를 저장한 리스트virusLocate = [] # 바이러스의 위치를 저장한 리스트virusGraph = [] # 바이러스가 퍼진 그래프tempGraph = [] # 그래프의 내용을 변경하기 위한 임시 그래프combinationsZeroLocate = [] #0의 좌표 중 3개 뽑는 경우의 수를 저장한 리스트result = 0 # 최종 안전 영역for i in range(N): graph.append(list(map(int, sys.stdin.readline().split()))) for j in range(M): if graph[i][j] == 0: zeroLocate.append([i, j]) elif graph[i][j] == 2: virusLocate.append([i, j])#virusGraph = copy.deepcopy(graph)virusGraph = [i[:] for i in graph]combinationsZeroLocate = (list(combinations(zeroLocate, 3)))for i in combinationsZeroLocate: temp = 0 tempGraph = copy.deepcopy(graph) tempGraph[i[0][0]][i[0][1]] = 1 tempGraph[i[1][0]][i[1][1]] = 1 tempGraph[i[2][0]][i[2][1]] = 1 for j in virusLocate: #virusGraph = copy.deepcopy(virus_BFS(j[0], j[1], tempGraph)) virusGraph = [i[:] for i in virus_BFS(j[0], j[1], tempGraph)] for j in virusGraph: temp += j.count(0) result = max(temp, result)print(result)결과입니다. 마지막으로 pypy3를 제출했더니 python3 보다 4.6배 속도가 빨라진 것을 확인할 수 있었습니다.다 풀고 이 문제를 검색해본 결과 대부분의 사람들이 백트래킹을 활용해서 푼것을 확인했습니다. 저 또한 다음에는 조합이 아닌 백트래킹을 활용해서 풀어보도록 하겠습니다." }, { "title": "스프링 입문 13 - 4.회원 관리 예제 - 백엔드 개발 (5)", "url": "/posts/Inflearn-spring13/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-07 19:11:00 +0900", "snippet": "회원 서비스 테스트이전시간에 만든 회원 서비스를 테스트 해보겠습니다. 이번시간에는 지난 번 테스트 케이스를 작성하는 것과 달리 MemberService 안에서 바로 테스트를 진행할 수 있습니다.MemberService를 선택 &amp;gt; Alt + Enter &amp;gt; Create Test &amp;gt; 멤버 모두 체크이렇게 하면 자동으로 TestCase가 자동으로 생성됩니다.테스트는 한글로 바꿔도 가능합니다. 빌드할 때 실제 코드에 반영되지 않고 영어권 사람들과 작업하는 것이 아니라면 직관적인 한글로 테스트를 하는 경우도 있으니 이번에는 한글로 메서드를 바꿔서 테스트 해보겠습니다.회원가입 서비스 테스트다음과 같이 코드를 작성하고 run을 실행합니다.@Test void 회원가입() { //given Member member = new Member(); member.setName(&quot;hello&quot;); //when Long saveId = memberService.join(member); //then Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); }assertThat은 org.assertj.core.api.Assertions에서 import static 한 메서드 입니다.테스트를 보통 3구간으로 나누어서 실험합니다.//given: 주어진 값들을 나타냅니다.//when: 조건이 들어간 부분입니다.//then: 테스트 결과부분을 나타냅니다.이 부분은 회원가입에서 예외 없는 부분을 테스트 한 경우입니다. 테스트에서는 예외처리가 잘 작동하는지도 중요하기 때문에 회원가입에서 중복으로 가입이 되는 지 알아보도록 하겠습니다.중복 회원 가입 예외처리 테스트try catch 문먼저 이름이 같은 경우에서 join을 2번 해보겠습니다. 그 후 try catch문으로 예외 처리를 합니다.@Test public void 중복_회원_예외(){ //given Member member1 = new Member(); member1.setName(&quot;spring&quot;); Member member2 = new Member(); member2.setName(&quot;spring&quot;); //when memberService.join(member1); // vaildateDuplicateMember(member)가 발생해야함 try { memberService.join(member2); fail(&quot;예외가 발생해야합니다.&quot;); }catch (IllegalStateException e){ assertThat(e.getMessage()).isEqualTo(&quot;이미 존재하는 회원입니다.&quot;); } //then }위와 같이 테스트 코드를 작성하고 실행을 해보았습니다.vaildateDuplicateMember(member)가 제대로 작동하여 에러가 발생하지 않았고 isEqualto를 통해 똑같이 에러 메세지가 같다는 것을 확인할 수 있었습니다.만약 예외처리를 잘못 했다면 다음과 같은 메세지가 출력됩니다.assertThrows 사용@Test public void 중복_회원_예외(){ //given Member member1 = new Member(); member1.setName(&quot;spring&quot;); Member member2 = new Member(); member2.setName(&quot;spring&quot;); //when memberService.join(member1); assertThrows(IllegalStateException.class, () -&amp;gt; memberService.join(member2));assertThrows()를 사용하기 위해서는 (static org.junit.jupiter.api.Assertions.)*; 클래스를 import 해야합니다.이는 () -&amp;gt; memberService.join(member2) 구문이 실행되면 IllegalStateException.class가 실행되어 예외를 처리하는 구조입니다.에러 메세지를 알기 위해 다음 코드를 추가합니다.assertThat(e.getMessage()).isEqualTo(&quot;이미 존재하는 회원입니다.&quot;);여기서도 테스트 케이스마다 추가로 메모리를 비우기 위해 다음 코드를 작성합니다.@AfterEach public void afterEach(){ memberRepository.clearStore(); }주의사항테스트의 Repository는 실제 MemoryMemberRepository클래스가 아닌 새로 만든 MemoryMemberRepository입니다. 둘은 서로 다른 인스턴스이고 이는 DB를 따로 쓰는 것과 마찬가지입니다.따라서 테스트와 실제 코드 모두 동일한 MemoryMemberRepository를 사용하기 위해서는 test패키지 MemberService의 코드를 다음과 같이 수정합니다.MemberService 클래스Alt + Insert &amp;gt; constructor &amp;gt; public MemberService … 선택하여 직접 생성하지 않고 외부에서 넣어주는 방식으로 생성합니다.MemberService 입장에서는 memberRepository를 직접 new하지 않고 외부에서 넣어준다고 생각할 수 있습니다. 위와 같은 과정을 DI(Dependency Injection)이라고 합니다.MemberServiceTest 클래스위 코드를 다음과 같이 변경합니다.이렇게 하면 같은 MemomryRepository를 사용할 수 있습니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다. 인텔리제이 주석줄 단위 : ctrl + /블록단위 : ctrl + shift + /이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 12 - 4.회원 관리 예제 - 백엔드 개발 (4)", "url": "/posts/Inflearn-spring12/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-07 17:49:00 +0900", "snippet": "회원 서비스 개발회원 리포지토리와 도메인을 활용해서 실제 비즈니스 로직을 작성하는 단계입니다. 서비스 클래스는 비즈니스에 가까운 이름으로 지어야 개발자와 기획자 모두 로직을 쉽게 파악할 수 있습니다.회원가입 기능/** 회원가입 **/ public Long join(Member member){ // 조건: 같은 이름을 가진 회원은 가입 X Optional&amp;lt;Member&amp;gt; result = memberRepository.findByName(member.getName()); result.ifPresent(m -&amp;gt; { throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;); }); memberRepository.save(member); return member.getId(); }Hello.Hellospring 패키지에 service라는 패키지를 하나 생성하고 그 안에 MemberService라는 클래스를 하나 생성합니다.그 후 MemoryMemberRepository() 객체를 하나 생성합니다.result가 Optional 이라서 여러 메소드를 사용할 수 있는데 그 중 ifPresent 값이 존재하면 확인을 합니다.만약 중복이라면 IllegalStateException가 작동해서 예외처리를 해줍니다. memberRepository.findByName(member.getName()) .ifPresent(m -&amp;gt; { throw new IllegalStateException(&quot;이미 존재하는 회원입니다.&quot;); });memberRepository.findByName은 이미 Optional로 선언되었기 때문에 간결하게 코드를 작성하고 싶으면 Optional을 지우고 바로 ifPresente를 사용합니다.그 후 memberRepository.findByName의 코드 블록을 드래그 한 후 우클릭 &amp;gt; Refactor &amp;gt; Extract Method 를 눌러 vaildateDuplicateMember라고 메서드 이름을 바꿔줍니다.이를 통해 join 메소드는 중복을 검증하고 바로 멤버를 저장합니다.회원 조회 기능 /** 전체 회원 조회 **/ public List&amp;lt;Member&amp;gt; findMembers() { return memberRepository.findAll(); }MemberService클래스에 findMembers()를 선언하고 List를 java.uilt 클래스로 import합니다.추가로 다음 메소드를 findMembers() 밑에 넣습니다.public Optional&amp;lt;Member&amp;gt; findOne(Long memberId){ return memberRepository.findById(memberId); }전체 코드입니다.Tip 변수를 클릭하고 Shift + F6 누르면 단락에 있는 이름이 같은 변수들을 한번에 바꿀 수 있습니다. Alt +Enter 를 누르면 바로 Local 가져올 수 있습니다.이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 11 - 4.회원 관리 예제 - 백엔드 개발 (3)", "url": "/posts/Inflearn-spring11/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-07 13:49:00 +0900", "snippet": "회원 리포지토리 테스트 케이스 작성테스트 케이스란?이전 시간에 작성한 MemberRepository 인터페이스, MemoryMemberRepository 등이 제대로 작동하는지 코드로 검증하는 방법으로 개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 통해서 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 해당 기능을 실행합니다.하지만 이러한 방법은 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있습니다.자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결합니다.JUnit을 통한 TestCase 작성이전 시간에 main 디렉토리에 repository 패키지를 만든 것 처럼, test 디렉토리에 repository라는 패키지를 새로 생성합니다.관례적으로 테스트를 실행할 패키지나 클래스의 이름 뒤에 Test 를 붙이는 방식으로 테스트 케이스를 작성합니다.이번 시간은 MemoryMemberRepository을 테스트 할 것입니다. 따라서 test &amp;gt; repository 에 MemoryMemberRepositoryTest 라는 클래스를 새로 생성합니다.MemoryMemberRepositoryTest 클래스는 굳이 Public으로 접근지정자를 설정하지 않아도 됩니다.MemoryMemberRepositoryTest 클에스에 다음과 같은 코드를 작성합니다.class MemoryMemberRepositoryTest { MemoryMemberRepository repository = new MemoryMemberRepository(); @Test public void save(){ Member member = new Member(); member.setName(&quot;spring&quot;); repository.save(member); }}save Testcase@Test 는 Junit에서 import 한 것입니다. 먼저 member객체를 만들고 그 member객체 이름을 spring으로 정하고 repository에 save했습니다. 이후 repository가 제대로 작동하는지 확인하기 위해 member의 getId()로 id를 찾았습니다.save 함수를 다시 살펴보면 id 는 ++sequence로 1씩 증가하는 것을 알 수 있습니다.class MemoryMemberRepositoryTest { MemoryMemberRepository repository = new MemoryMemberRepository(); @Test public void save(){ Member member = new Member(); member.setName(&quot;spring&quot;); repository.save(member); Member result = repository.findById(member.getId()).get(); }}findById는 반환형이 Optional이므로 get()이라는 함수를 통해서 꺼낼 수 있습니다. get()으로 꺼낸 값을 result에 저장합니다. @Test public void save(){ Member member = new Member(); member.setName(&quot;spring&quot;); repository.save(member); Member result = repository.findById(member.getId()).get(); Assertions.assertEquals(member, result); }}result에 값이 제대로 들어왔는지 확인하기 위해 JUnit에서 제공하는 Assertions의 assertEquals 함수를 사용하여 save함수를 run 합니다.- Assertions에서 값이 일치하지 않는 경우기댓값과 실제값이 달라 에러가 발생하는 것을 확인할 수 있었습니다.- Assertions에서 값이 일치하는 경우로그가 아무것도 찍히진 않지만 왼쪽에 모두 초록색 체크가 나오며 에러가 발생하지 않았다는 것을 확인 할 수 있었습니다.org.assert.core.api의 Assertions 사용요즘은 org.assert.core.api의 Assertions를 더 많이 사용합니다.Assertions.assertThat()함수의 자세한 사용은 다음과 같습니다. @Test public void save(){ Member member = new Member(); member.setName(&quot;spring&quot;); repository.save(member); Member result = repository.findById(member.getId()).get(); //Assertions.assertEquals(member, result); Assertions.assertThat(member).isEqualTo(result); }}Add on-demand static imoort를 사용하면 assertThat함수를 바로 사용할 수 있습니다.findByName Testcase@Test public void findByName(){ Member member1 = new Member(); member1.setName(&quot;spring1&quot;); repository.save(member1); Member member2 = new Member(); member2.setName(&quot;spring2&quot;); repository.save(member2); Member result = repository.findByName(&quot;spring1&quot;).get(); assertThat(result).isEqualTo(member1); }spring1, spring2 라는 회원이 가입을 했다고 케이스를 작성하고 assertThat(result).isEqualTo(객체이름)으로 findById함수를 run하여 test 해보았습니다.여기서 spring 1을 2로 바꾸거나 member1을 2로 바꾸는 경우 에러가 발생합니다.또한 각 함수별로 작동시키지 않고 Class로 묶어서 함께 test를 진행할 수도 있습니다.findAll Testcase@Test public void findAll(){ Member member1 = new Member(); member1.setName(&quot;spring1&quot;); repository.save(member1); Member member2 = new Member(); member2.setName(&quot;spring2&quot;); repository.save(member2); List&amp;lt;Member&amp;gt; result = repository.findAll(); assertThat(result.size()).isEqualTo(2); assertThat(result).isEqualTo(3);//에러 }주의사항이렇게 코드를 작성할 경우 MemoryMemberRepositoryTest의 함수들이 순서대로 test가 진행되지 않고 무작위로 진행됩니다. 또한 findByName()에서 선언한 객체가 Repository에 그대로 남아있어 findAll()에서 테스트 할 경우 이름이 겹치는 객체가 존재하여 에러가 발생합니다.이를 고치기 위해 매 test마다 repository를 clean하는 함수를 작성해야 합니다.Repository clean 함수MemoryMemberRepositoryTest 클래스 맨 위에 다음과 같은 코드를 작성합니다.@AfterEach public void afterEach(){ repository.clearStore(); }@AfterEach는 @Test하는 메서드가 끝날때 마다 실행하는 메서드로 save(), findByName(), findAll() 테스트가 끝날때마다 한번씩 실행됩니다.이를 위해 MemoryMemberRepository 에 다음과 같은 메서드를 추가합니다.public void clearStore(){ store.clear(); }clear()함수를 통해 저장된 store를 비웁니다.@AfterEach를 통해 에러 없이 정상적으로 test가 실행되는 것을 확인할 수 있었습니다.TDD 테스트 주도 개발오늘 한 테스트케이스 작성을 나중에 하는 것이 아니라 테스트케이스를 먼저 만들고 이에 맞는 함수나 메서드, 클래스를 코딩하는 개발 방법론으로 테스트 주도 개발, TDD(Test-Driven-Development)이라고 합니다.이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 10 - 4.회원 관리 예제 - 백엔드 개발 (2)", "url": "/posts/Inflearn-spring10/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-05 22:26:00 +0900", "snippet": "회원 도메인과 리포지토리 만들기회원 객체 생성Hello.Hellospring 패키지에 domain이라는 패키지를 생성합니다. Member라는 클래스를 생성하고 id, name 이라는 변수를 선언합니다.여기서 id는 사용자가 입력한 id가 아닌 시스템이 회원을 구분하지 위한 고유의 id 값입니다.그 후 getter, setter 객체를 생성합니다.리포지토리 생성Hello.Hellospring 패키지에 MemberRepository를 클래스가 아닌 인터페이스로 생성합니다.import Hello.Hellospring.domain.Member;를 추가하여 Member에서 빨간색을 없애줍니다.빨간줄을 없애는 방법은 Member 우클릭 &amp;gt; Show Context Action &amp;gt; import class &amp;gt; Hello.Hellospring.domain.Member 선택Optional을 추가하고 빨간줄을 없애는 방법입니다. Optional은 Java 8 부터 있는 기능으로 findById를 가져올 때, NULL 값일 수 있는데 이를 처리를 할 때, Optional을 감싸서 처리를 합니다.package Hello.Hellospring.repository;import Hello.Hellospring.domain.Member;import java.util.List;import java.util.Optional;public interface MemberRepository { Member save(Member member); //회원 저장 Optional&amp;lt;Member&amp;gt; findById(Long id); //회원을 id로 찾기 Optional&amp;lt;Member&amp;gt; findByName(String Name); //회원을 이름으로 찾기 List&amp;lt;Member&amp;gt; findAll(); //저장된 모든 회원 출력}MemberRepository 코드에 리포지토리의 save, findById, findByName, findAll이라는 4가지 기능을 만들었습니다.구현체 생성Repository 패키지에 MemoryMemberRepository라는 클래스를 생성하고 MemberRepository를 implements합니다.빨간줄이 뜨는 건 위와 같이 해결합니다.값을 저장할 공간을 구현하기 위해 Map을 사용하여 키-값 쌍 List를 만듭니다. Map 빨간줄을 없애기 위해 이전처럼 Map을 Option에서 import합니다.sequence: 키값인 id를 자동으로 생성해주는 변수입니다.MemoryMemberRepository 클래스 내부의 구체적은 메소드들의 내용은 다음과 같습니다. save()@Override public Member save(Member member) { member.setId(++sequence); store.put(member.getId(), member); return member; } findById() @Override public Optional&amp;lt;Member&amp;gt; findById(Long id) { return Optional.ofNullable(store.get(id)); }Optional은 만약 get함수가 NULL값을 가져와도 클라이언트가 에러가 발생하지 않고 처리가 가능하다. findById()@Override public Optional&amp;lt;Member&amp;gt; findByName(String name) { return store.values().stream() .filter(member -&amp;gt; member.getName().equals(name)) .findAny(); }stream(): 루프를 돌리는 함수입니다.filter(): 파라미터의 name과 member의 name과 같은지 비교하는 함수입니다.findAny(): name과 같은 이름을 하나라도 찾는 함수입니다. findAll() @Override public List&amp;lt;Member&amp;gt; findAll() { return new ArrayList&amp;lt;&amp;gt;(store.values()); }private static Map&amp;lt;Long, Member&amp;gt; store = new HashMap&amp;lt;&amp;gt;();를 보면 Map형식이지만findAll()의 반환은 List입니다.store.values()는 Map&amp;lt;Long, Member&amp;gt;에서의 Member들 가리킵니다.전체 코드는 다음과 같습니다.이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 것을 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 9 - 4.회원 관리 예제 - 백엔드 개발 (1)", "url": "/posts/Inflearn-spring9/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-05 22:03:00 +0900", "snippet": "비즈니스 요구사항 정리데이터: 회원 ID, 이름기능: 회원 등록, 조회이번 백엔드 개발은 자바 스프링의 생태계를 배우기 위한 것이라서 매우 단순하게 요구사항을 정하였습니다.일반적인 웹 어플리케이션 계층 구조 컨트롤러: 웹 MVC의 컨트롤러 역할 서비스: 핵심 비즈니스 로직 구현되어있습니다. 예시 회원은 중복가입 X 리포지토리: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리 도메인: 비즈니스 도메인 객체, 예)회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리됨클래스 의존관계 MemberService: 회원 비즈니스 로직을 담당합니다. MemberRepository: 회원을 저장하는 것은 인터페이스로 설계합니다. 이유는 아직 데이터 저장소가 정해지지 않아서 임시로 메모리 구현로 데이터를 만들고 이후 데이터 저장소가 정해지면 그 저장소로 데이터 바꾸기 위해 인터페이스로 설계합니다. MemoryMemberRepository: 아직 데이터 저장소가 선정되지 않아서 구현체로 가벼운 메모리 기반의 데이터 저장소 사용합니다이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 들으며 공부한 내용을 직접 정리한 것입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 8 - 3.스프링 웹 개발 기초 - API", "url": "/posts/Inflearn-spring8/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-05 20:30:00 +0900", "snippet": "정적 컨텐츠를 제외하면 크게 MVC 방식에서 view를 찾아서 템플릿 엔진을 통해서 화면을 렌더링 하여 HTML을 웹 브라우저에 넘기는 방식과 API 방식이 있습니다. 오늘은 API 방식을 알아보도록 하겠습니다.APIHelloController 클래스에 다음과 같은 메소드를 새로 추가합니다.@Controllerpublic class HelloController { @GetMapping(&quot;hello-string&quot;) @ResponseBody public String helloString(@RequestParam(&quot;name&quot;) String name){ return &quot;hello &quot; + name; // hello spring }@ResponseBody: HTTP는 start line, header, body 3부분으로 나뉘는데 @ResponseBody가 body에 &quot;hello&quot; + name;라는 데이터를 직접 넣어주겠다는 의미 입니다.여기서 HTTP의 body와 HTML &amp;lt;body&amp;gt; 태그를 헷갈리시면 안됩니다.즉 서버에게 요청한 클라이언트에게 바로 hello&quot; + string 이 바로 전달됩니다.이것은 템플릿 엔진과 달리 변형없이 바로 전달됩니다.스프링을 실행하고 http://localhost:8080/hello-string?name=osnim을 브라우저에 입력했고 다음과 같은 결과를 얻을 수 있었습니다.위의 사진이 helloString 메소드 입니다. 오른쪽 사진은 소스 코드를 나타낸 것으로 API를 통해 클라이언트의 Request를 Response한 결과는 소스코드를 볼 수 없습니다.(크롬 관리자 도구를 통해서는 확인이 가능했습니다.)아래 사진은 비교를 위해 넣은 이전 시간 HelloMvc메소드의 Response를 나타냅니다. API와 템플릿 엔진을 활용한 MVC 의 차이가 무엇인지 알아보기 위해 넣었습니다.하지만 API는 위의 예시처럼 화면을 표현하기 보다는 데이터를 보내기 위해 더 많이 사용합니다.HelloController 클래스에 Hello 라는 클래스를 만들어 Hello라는 객체를 생성하고 Getter, Setter를 만들어 private 객체를 접근할 수 있는 메서드를 생성합니다.Windows 환경에서는 Alt + Insert 단축키 &amp;gt; Generate 통해 Getter, Setter를 빠르게 만들 수 있습니다.helloApi라는 메소드를 새로 만들고 hello 라는 객체를 새로 생성합니다.그 다음 setName()을 통해서 name 파라미터를 Hello에 넣어줍니다.스프링을 실행하면 화면입니다. 이전과 달리 API는 JSON 형식으로 값이 반환되는 것을 확인할 수 있습니다.스프링에서 API를 반환하면 기본적으로 JSON 형식으로 반환을 하게 세팅이 되어있습니다.@ResponseBody 사용원리스프링에서 받은 HelloController 안에 hello-api가 있어서 확인을 하는데 @ResponseBody 어노테이션이 붙어있는 것을 확인하면 viewResolver에 보내지 않고HttpMessageConverter가 동작하여 Body에 JSON 형식으로 데이터를 넣어 클라이언트에 보냅니다.여기서 문자는 StringConverter가 작동하고 문자가 아닌 객체인 경우, JsonConverter가 작동합니다.객체를 JSON으로 바꿔주는 유명한 라이브러리는 크게 Google에서 만든 Gson과 Jackson이 있지만 스프링은 Jackson을 기본으로 탑재했습니다.이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "Algorithm 3.DFS/BFS", "url": "/posts/HOW-to-Solve-DFS-BFS/", "categories": "Algorithm", "tags": "Algorithm, DFS, BFS", "date": "2022-03-04 14:37:00 +0900", "snippet": "탐색 (Search)많은 양의 데이터 중에서 원하는 데이터를 찾는 과정으로 그래프, 트리등의 자료구조 안에서 탐색이라는 과정을 사용합니다.대표적인 탐색 알고리즘으로는 DFS, BFS이 있습니다.이러한 탐색 알고리즘을 사용하기 위해서는 스택(Stack)과 큐(Queue)라는 자료구조를 사용합니다. 자료구조: 데이터를 표현하고 관리하고 처리하기 위한 구조스택과 큐는 push(삽입), pop(삭제) 함수들을 사용합니다.push(삽입), pop(삭제)를 사용하기 위해서는 오버플로우(Overflow), 언더플로우(Underflow)를 고려해야 합니다.오버플로우(Overflow): 스택과 큐 등의 자료구조의 용량이 가득 찬 상태에서 push()를 수행할 경우 발생합니다.언더플로우(Underflow): 스택과 큐 등의 자료구조의 데이터가 없는 상태에서 pop()를 수행할 경우 발생합니다.인접행렬, 인접리스트인접행렬(Adjacency Matrix): 2차원 배열에 연결된 모든 노드들의 정보를 기록하는 방식으로 메모리 낭비가 심합니다.인접리스트(Adjacency List): 2중 List로 연결된 노드만 기록하는 방식으로 메모리 관리 측면에서 효율적입니다. 하지만 두 노드가 연결되어있는지 확인하는 것은 인접행렬보다 느립니다.DFS (Depth-First-Search, 깊이 우선 탐색)DFS에서 사용되는 기본 자료구조는 스택(Stack)입니다. DFS는 탐색할 수 있는 최대 깊이 부터 우선 탐색하며 더 이상 탐색할 곳이 없으면 스택에서 값을 하나 빼서 가장 나중에 들어온 노드를 방문하는 방식으로 모든 노드를 순회(Traversal)합니다.기본적으로 파이썬에서 list는 스택 자료구조로 되어있어 따로 구현하거나 import 하지 않아도 됩니다.DFS의 동작 순서는 다음과 같습니다. 탐색 시작 노드를 스택에 삽입하고 방문 처리합니다 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리합니다방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다. 2번 과정을 더 이상 수행할 수 없을 때 까지 반복합니다DFS의 탐색 순서를 보면 다음과 같습니다.DFS는 일반적으로 인전합 노드 중에서 방문하지 않은 노드가 여러 개 있으면 숫자가 낮은 노드 부터 탐색합니다.지금부터 DFS가 자세하게 어떤 식으로 탐색하는지 알아보도록 하겠습니다.먼저 시작 노드를 ‘1’을 스택에 넣고 방문처리 합니다. 스택의 최상단 노드인 ‘1’에 방문하지 않은 인접노드 ‘2’, ‘6’, ‘8’ 중에서 가장 낮은 번호를 가진 노드를 우선 탐색하고 stack에 ‘2’를 삽입합니다.스택의 최상단 노드인 ‘2’번 노드와 인전합 노드중 가장 낮은 번호의 노드인 ‘3’을 stack에 넣고 ‘3’번 노드를 방문 처리합니다.‘3’번 노드의 인접 노드인 ‘4’번 노드를 스택에 넣고 방문처리합니다. 이런식으로 더 이상 깊게 탐색할 수 없을 때 까지 반복합니다.‘5’번 부터 방문할 수 있는 인접 노드가 없기 때문에 ‘5’번 노드를 스택에서 꺼냅니다.이런 방식으로 ‘2’번 노드만 남기고 모두 스택에서 꺼냅니다.‘6’번 노드에서 인접한 노드 ‘7’, ‘8’번 노드 중에서 숫자가 낮은 순서대로 스택에 넣고 탐색을 합니다. (i) 번째 그림은 최종 DFS의 탐색 순서 및 결과입니다.DFS를 python 코드로 나타내면 다음과 같습니다.def dfs(graph, v, visited): visited[v] = True print(v, end=&#39;&#39;) for i in graph[v]: if not visited[i]: dfs(graph, i, visited)graph = [ [],[2, 6 ,8],[1, 3, 5],[2, 5],[3, 5],[2, 3, 4],[1, 2, 7, 8],[6],[1, 6] ]visited = [False]*9dfs(graph, 1, visited)BFS (Breadth-First-Search, 너비 우선 탐색)BFS는 가까운 노드부터 탐색하는 알고리즘으로 큐(Queue)라는 자료구조를 이용합니다.인접한 노드를 반복적으로 큐에 넣어 먼저 들어온 노드를 먼저 나가도록 구현하여 가까운 노드부터 탐색하면서 모든 노드를 순회(Traversal)합니다.BFS의 동작 순서는 다음과 같습니다. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 합니다. 2번 과정을 수행할 수 없을 때까지 반복합니다.기본적으로 파이썬에서는 큐를 구현하지 않고 Queue 라이브러리를 사용하여 큐 자료구조를 이용합니다.BFS의 탐색 순서를 보면 다음과 같습니다.BFS가 어떻게 작동하는지 구체적으로 살펴보겠습니다.먼저 시작노드인 ‘1’번 노드를 큐에 삽입하고 방문 처리합니다.큐에서 노드 ‘1’을 꺼내고 방문하지 않은 인접노드 ‘2’, ‘3’, ‘4’를 큐에 삽입합니다.인접노드 중에서 가장 먼저 들어온 ‘2’번 노드를 방문 처리하고 큐에서 pop합니다. 그 후 인접노드를 삽입합니다. 하지만 2번 노드는 모두 큐에 있거나 삽입 되어있어 추가되는 노드는 없습니다.‘3’번 인접노드인 ‘5’번 ‘4’번 큐에 삽입하고 방문 처리합니다. 그 후 ‘4’번 인접노드인 ‘6’, ‘7’번 노드를 큐에 삽입합니다.위와 같은 방식으로 큐에 먼저 들어온 노드들을 탐색하여 BFS를 마무리합니다.마지막 그림은 BFS의 탐색 순서를 나타낸 그림입니다.BFS를 python 코드로 나타내면 다음과 같습니다.from collections import dequedef BFS(graph, start, visited): queue = deque([start]) visited[start] = True while queue: v = queue.popleft() print(v, end=&#39;&#39;) for i in graph[v]: if not visited[i]: queue.append(i) visited[i] = Truegraph = [[],[2, 6 ,8],[1, 3, 5],[2, 5],[3, 5],[2, 3, 4],[1, 2, 7, 8],[6],[1, 6] ]visited = [False]*(9)BFS(graph, 1, visited)DFS, BFS 탐색 비교동일한 트리에서 DFS, BFS 탐색 순서를 비교한 그림입니다. 이해에 조금이라도 도움을 드리고자 첨부하였습니다.참조본 글은 제가 전공수업으로 들었던 ‘빅데이터처리및응용’과 나동빈 저 ‘이것이 코딩테스트다 with 파이썬’를 바탕으로 공부하여 정리한 내용입니다." }, { "title": "백준 2873 롤러코스터 (python)", "url": "/posts/BOJ-2873/", "categories": "BOJ", "tags": "Greedy, 2873, 구현, 구성적", "date": "2022-03-03 02:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/2873처음 생각한 접근법R행 C열 크기의 직사각형을 모눈종이에 그려보고 최대한 많은 경로를 이동하는 방법을 생각했습니다.여러가지 경우의 수를 생각하다 보니 몇 가지 패턴이 보였습니다.먼저 R 또는 C 가 홀수일 경우 모든 경로를 탐색 할 수 있었습니다. 즉 기쁨의 숫자와 상관 없이 R, L, U, D 를 조합하면 되었습니다. R이 홀수인 경우는 다음과 같은 패턴으로 이동합니다. C이 홀수인 경우 다음과 같은 패턴으로 이동합니다. 마지막으로 R과 C가 모두 짝수인 경우는 1칸만 방문 못하고 모든 곳을 방문한다고 생각했습니다. 하지만 여기서부터 잘못 생각하여 시간이 많이 뺏겼고 답을 도출해내지 못했습니다.다음은 제가 생각한 경우의 수 입니다.저는 처음에 경우의 수를 위 그림과 같이 2가지만 생각했습니다. 도착점([R-1][c-1])의 위나 왼쪽만 고려하여 둘 중 큰 값을 가진 곳으로 방문하면 된다고 생각했습니다.그리고 위를 바탕으로 코드를 다음과 같이 작성하여 제출하였습니다.처음 제출한 코드import sysR, C = map(int, sys.stdin.readline().split())Graph = [list(map(int, sys.stdin.readline().split())) for _ in range(R)]result = &#39;&#39;# 행이 홀수일 경우if R%2 == 1: for i in range(R): #홀수 번째 행 if i % 2 == 0: result += &#39;R&#39;*(C-1) if i == R-1: break #짝수 번째 행 else: result += &#39;L&#39;*(C-1) result += &#39;D&#39;#열이 홀수인 경우elif C%2 == 1: for i in range(C): #홀수 번째 열 if i % 2 == 0: result += &#39;D&#39;*(R-1) if i == C-1: break #짝수 번째 열 else: result += &#39;U&#39;*(R-1) result += &#39;R&#39;#행, 열 모두 짝수인 경우 =&amp;gt; 도착점 왼쪽, 위 중 큰 값으로 가면 됨else: # 왼쪽이 큰 경우 if Graph[R-1][C-2] &amp;gt;= Graph[R-2][C-1]: for i in range(R-1): # 아래에서 2번째 행일때 if i == R-2: result += &#39;DR&#39; + &#39;URDR&#39; * int((C-2)/2) # 홀수 번째 행 elif i % 2 == 0: result += &#39;R&#39; * (C - 1) + &#39;D&#39; # 짝수 번째 행 else: result += &#39;L&#39; * (C - 1) + &#39;D&#39; # 위쪽이 큰 경우 else: for i in range(C-1): # 아래에서 2번째 행일때 if i == C - 2: result += &#39;RD&#39; + &#39;LDRD&#39; * int((R - 2) / 2) # 홀수 번째 행 elif i % 2 == 0: result += &#39;D&#39; * (R - 1) + &#39;R&#39; # 짝수 번째 행 else: result += &#39;U&#39; * (R - 1) + &#39;R&#39;print(result)오답 분석7%는 맞았다고 나왔다가 틀렸습니다가 출력되는 것을 보고 짝수의 경우의 수를 더 생각해봤습니다. 그 결과 다음과 같은 경우의 수도 존재한다는 것을 깨달았습니다.이렇게 여러가지 경우의 수가 더 존재하다는 것을 깨닫고 하루종일 고민을 하다가 도저히 풀리지 않아 구글링을 통해 힌트를 얻었습니다.저는 한 블로그만 보면 객관적이거나 다양한 풀이 방법을 배우지 못한다고 생각해서 여러가지 사이트를 봤습니다. 하지만 대부분 체스판으로 설명을 하며 저와 비슷한 어려움을 겪은 분들이 생각보다 많았습니다.위 문제는 초록색으로 표시된 위치에서 최소값을 찾아 그 위치를 제외하고 지나가야 합니다.여기서의 중요한 포인트는 초록색으로 표시된 위치의 패턴을 찾아야합니다.여러가지로 패턴을 표현할 수 있지만 저는 이런경우에 수학적으로 접근하려고 합니다. R과 C를 그래프로 나타내었을 때 인덱스로 나타낸 x,y 좌표 값의 합이 홀수인 것을 파악하고 2중 for문을 돌려 최소값을 찾아내었습니다.그런데 저는‘만약 초록색으로 표시된 위치 말고 다른 위치에 최소값이 있으면 어떡하지?, 이것도 처리해줘야 하는 것 아닌가?’하는 의문이 들었습니다.하지만 여러가지 경우의 수를 체크해본 결과 이는 고려할 필요가 없는 경우였습니다.그 이유는 만약 초록색으로 표시된 위치를 제외한 곳에 최소값이 있어 그 경우를 피하기 위해서는 초록색으로 표시된 위치 2개를 방문할 수 없게 됩니다.위 경우는 1이라는 최소값을 피하기 위해 임의의 방문 경로를 나타낸 것입니다. 하지만 그 1을 피하기 위해 양 옆 2군데를 모두 방문할 수 없게 됩니다.즉 초록색으로 표시된 위치를 제외한 곳을 고려한 순간 그리디 알고리즘에서 벗어나게 되며 초록색으로 표시된 위치만을 고려했을 경우보다 무조건 기쁨의 합이 적게됩니다.저는 이러한 경우의 수를 다 고려하여 다시 자세하게 경우의 수를 고려했습니다.짝수 x 짝수 크기의 직사각형 경우의 수위 문제는 행을 두 개씩 짝을 지어 풀어야 합니다. 그래야 지그재그 패턴이 아닌 다른 경로들을 바로 찾을 수 있기 때문이고 이게 곧 그리디 알고리즘이기 때문입니다.저는 예시를 6 x 6 직사각형으로 하였지만 2, 4, 8, 10 등 모두 가능합니다.1. 0~1 구간에 최소값이 존재하는 경우위 경우에서 최소값이 첫 번째 행 또는 두 번째 행에 존재하는 경우입니다.처음부터 DRUR 패턴으로 for문을 1부터 시작하여 2씩 증가시킵니다. 만약 for문의 변수가 최소값의 열과 같아지는 경우가 생기면 DR을 추가하고 다음 반복문 부터는 RURD 패턴으로 변경하여 문자열을 저장합니다.만약 최소값이 2개로 나눈 구간중 2번째에 나타난다면 DRUR 패턴을 반복하다가 RD를 결과에 저장하고 다음 반복 부터는 RURD를 추가합니다.즉 최소값이 있는 칸을 방문하기 전까지는 DRUR 패턴과 방문하고 난 후 RURD 패턴은 같지만 위냐 아래냐에 따라 이동경로가 달라지는 경우를 구분지어야 합니다.0~1구간이 종료되면 결과에 D 입력을 저장합니다. 다음 2개 행에 방문하기 전이 기 때문입니다.코드는 다음과 같습니다.저는 최소값을 지나는 경우를 PASS 라는 변수를 선언하여 구분지었습니다.# MIN의 행 인덱스가 i 또는 i+1 일 경우 if MIN[1] == i: for j in range(1, C, 2): # 행 인덱스가 짝수일 경우 if MIN[2] == j: result += &#39;DR&#39; PASS = True else: if PASS == False: result += &#39;DRUR&#39; else: result += &#39;RURD&#39; result += &#39;D&#39; elif MIN[1] == i + 1: for j in range(0, C, 2): # 행 인덱스가 홀수일 경우 if MIN[2] == j: result += &#39;RD&#39; PASS = True else: if PASS == False: result += &#39;DRUR&#39; else: result += &#39;RURD&#39; result += &#39;D&#39;2. 2~3 구간에 최소값이 존재하는 경우위 경우는 최소값이 중간에 존재하는 경우입니다. 위 예시는 6행 기준이고 일반적으론 [0,1], [n-2,n-1] 행을 제외한 모든 구간에서 적용이 가능합니다.위 그림에서 보다 시피 중간 구간 이전과 이후의 패턴이 변화된 것을 볼 수 있습니다.따라서 PASS가 True로 변하고 True 이후 부터는 패턴을 다르게 적용시켰습니다. 코드는 다음과 같습니다. # 최솟값 안 지나고 MIN 행 인덱스가 i도 아니고 i+1 아닌 경우 ㄷ 반대 모양 만들기 else: result += &#39;R&#39; * (C-1) + &#39;D&#39; + &#39;L&#39; *(C-1) +&#39;D&#39; else: result += &#39;L&#39; * (C - 1) + &#39;D&#39; + &#39;R&#39; * (C - 1) + &#39;D&#39;정답 코드import sysR, C = map(int, sys.stdin.readline().split())Graph = [list(map(int, sys.stdin.readline().split())) for _ in range(R)]result = &#39;&#39;# 행이 홀수일 경우if R%2 == 1: for i in range(R): #홀수 번째 행 if i % 2 == 0: result += &#39;R&#39;*(C-1) if i == R-1: break #짝수 번째 행 else: result += &#39;L&#39;*(C-1) result += &#39;D&#39; print(result)#열이 홀수인 경우elif C%2 == 1: for i in range(C): #홀수 번째 열 if i % 2 == 0: result += &#39;D&#39;*(R-1) if i == C-1: break #짝수 번째 열 else: result += &#39;U&#39;*(R-1) result += &#39;R&#39; print(result)#행, 열 모두 짝수인 경우 =&amp;gt; x좌표,y좌표 인덱스 합이 홀수 중에서 가장 작은거 찾기else: MIN = [1001, 0, 1] # 최소값, x좌표, y좌표 PASS = False # 최소 지점을 지나간 경우를 표시 for i in range(R): for j in range(C): if (i+j)%2 == 1: if MIN[0] &amp;gt; Graph[i][j]: MIN = [Graph[i][j], i, j] #print(MIN) for i in range(0, R, 2): if PASS == False: # MIN의 행 인덱스가 i 또는 i+1 일 경우 if MIN[1] == i: for j in range(1, C, 2): # 행 인덱스가 짝수일 경우 if MIN[2] == j: result += &#39;DR&#39; PASS = True else: if PASS == False: result += &#39;DRUR&#39; else: result += &#39;RURD&#39; result += &#39;D&#39; elif MIN[1] == i + 1: for j in range(0, C, 2): # 행 인덱스가 홀수일 경우 if MIN[2] == j: result += &#39;RD&#39; PASS = True else: if PASS == False: result += &#39;DRUR&#39; else: result += &#39;RURD&#39; result += &#39;D&#39; # 최솟값 안 지나고 MIN 행 인덱스가 i도 아니고 i+1 아닌 경우 ㄷ 반대 모양 만들기 else: result += &#39;R&#39; * (C-1) + &#39;D&#39; + &#39;L&#39; *(C-1) +&#39;D&#39; else: result += &#39;L&#39; * (C - 1) + &#39;D&#39; + &#39;R&#39; * (C - 1) + &#39;D&#39; print(result[0:-1])#마지막 D 는 뺌후기이 문제를 처음 제출한 건 22년 3월 1일 새벽 3시 였습니다. 이 문제를 거의 하루종일 매달리고 있었습니다. 즉 시작은 22년 2월 말이었습니다.처음에 문제를 보았을 때, 그리디 유형이라서 문제가 단순하게 읽혀서 쉽게 생각했습니다. 정말 큰 오산이었습니다. 이 문제 때문에 3일동안 다른 백준 문제를 풀지 못했습니다. 그만큼 풀고 싶었고 포기하고 싶지 않았습니다.그런데 도저히 짝수 x 짝수 크기의 정사각형 부지에서는 풀리지 않아 웹 검색을 해보았습니다.단, 코드는 절대 보지 않았으며 아이디어만 얻었습니다.모두 똑같이 체스판을 이용해서 설명을 하는 것을 보고 이 문제는 다른 아이디어를 생각하기 어려울 정도로 고난이도 문제라는 것을 깨달았으며, 아이디어나 접근법은 알아도 실제 많은 조건을 구분해 가며 구현해야 하기 때문에 실제로 매우 까다로웠습니다.많이 어려웠지만 제가 정답을 맞아서 많이 높아봐야 골드1 이나 골드2 문제인 줄 알았는데 플레티넘 3라서 기분이 좋았고 그 동안의 스트레스랑 고통이 다 날라갔습니다.비록 처음부터 끝까지 제 스스로 코드를 짜진 않았지만 홀수의 경우는 다 맞았고 짝수 부분도 힌트만 얻고 바로 코드로 구현해서 정답이 되었다는 것이 신기헀습니다.이번을 계기로 더 열심히해서 다음에는 플레티넘 문제도 스스로 맞춰보도록 제 스스로를 단련시키겠습니다.글을 다 쓰니 벌써 새벽 4시가 되었네요.. 얼른 자고 내일은 DFS/BFS 문제 풀어보도록 하겠습니다!오타나 궁금한 점 있으면 github로 로그인 후 아래에 댓글 달아주세요! 질문과 피드백은 언제든지 환영입니다." }, { "title": "프로그래머스 - SQL(JOIN-1) 없어진 기록 찾기", "url": "/posts/programmers-SQL-join1/", "categories": "SQL", "tags": "Programmers, SQL, MySQL", "date": "2022-03-02 18:33:00 +0900", "snippet": "SQL JOINSQL에서 JOIN이란 두 개 이상의 테이블(릴레이션)을 연결하여 데이터를 검색하는 방법으로 두 테이블에서 관련된 튜플을 결합하여 하나의 튜플로 만들어 출력합니다.JOIN은 DML중 SELECT에서 조건을 추가할 때 사용하는 방법으로 보통 기본키(PK)와 외래키를 사용하여 JOIN을 합니다.JOIN의 종류를 밴 다이어그램으로 표현하면 다음과 같습니다.위 그림을 SQL로 표현하면 다음과 같습니다. SELECT &amp;lt;필드 명...&amp;gt; FROM [기준 테이블 명] LEFT JOIN [JOIN 되는 테이블] ON [기준 테이블.외래키] = [JOIN 테이블.기본키] 꼭 외래키와 기본키일 필요는 없지만 대부분 외래키, 기본키를 이용하여 코드를 작성한다고 생각하여 위와 같이 작성했습니다. RIGHT JOIN은 LEFT JOIN에서 기준 테이블만 반대로 하면 되는거라서 자세하게 적지 않았습니다. on 은 where와 같은 역할을 하지만 자세한 차이점은 on은 레코드가 생성될 때 레코드를 필터링하는 반면에, where는 조인작업이 완료될 때까지 기다리고 난 뒤에 필터링을 합니다. 문제출처: https://programmers.co.kr/learn/courses/30/lessons/59042풀이 및 오답 정리이 문제는 ANIMAL_OUTS 테이블에는 동물들의 ID가 있는데 ANIMAL_INS에 없는 동물들의 ID를 찾는 방식으로 ANIMAL_OUTS 차집합을 찾아 풀어야합니다.JOIN은 대부분 있을 때 A테이블에 있고 B테이블에 있을 때 =를 사용한다는 것을 파악했습니다.이번 문제는 없는 경우를 찾는 것이라서 다음과 같이 작성하였습니다. != 문법이 없으면 에러가 발생할 것이라고 생각해서 다음과 같이 코드를 작성하고 결과를 보았습니다. SELECT ANIMAL_OUTS.ANIMAL_ID, ANIMAL_OUTS.NAME FROM ANIMAL_OUTS LEFT JOIN ANIMAL_INS ON ANIMAL_OUTS.ANIMAL_ID != ANIMAL_INS.ANIMAL_ID결과는 다음과 같습니다.중복된 값이 나오지만 제대로 출력이 나온다고 생각해서 !=에서는 문제가 없다고 생각해서 DISTINCT 만 추가하면 되는 줄 알았습니다.하지만 DISTINCT를 추가해도 문제는 계속 틀렸습니다.제가 착각하고 있었던 부분은 JOIN에서 기준 테이블의 키가 비교되는 테이블에 없으면 그 튜플은 출력이 안되는 줄 알았습니다.하지만 아래 그림에서 처럼 NULL 값으로 대체되어 출력되는 것을 새롭게 알게 되었습니다.!= 에서 문제가 있을 것이라고 생각하고 JOIN에 대한 여러 예제를 찾아보고 [w3schools]https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all 에서 기본 제공하는 테이블을 이용해서 직접 JOIN을 이용해서 튜플들을 출력해 보았습니다.제가 사용한 두 개의 테이블은 다음과 같습니다. Categories 테이블 Shippers 테이블 결과는 다음과 같았습니다. 바로 값이 없는 경우 NULL을 출력하여 기준 테이블에 맞춰 튜플이 출력되는 것을 확인할 수 있었습니다. 그래서 이 경우는 NULL 존재하는 경우만 출력해야 합니다. 따라서 JOIN에 WHERE절을 추가하고 값이 없는 경우, !=이 아니라 NULL 이라는 키워드를 사용해서 튜플이 없는 경우는 출력시키지 않아야 합니다.정답 코드 SELECT ANIMAL_OUTS.ANIMAL_ID, ANIMAL_OUTS.NAME FROM ANIMAL_OUTS LEFT JOIN ANIMAL_INS ON ANIMAL_OUTS.ANIMAL_ID = ANIMAL_INS.ANIMAL_ID WHERE ANIMAL_INS.ANIMAL_ID IS NULL정답을 알고나면 쉬워 보이지만 처음 JOIN을 이용한 저로서는 왜 WHERE절이 필요한지 궁금증이 생겨 깊게 공부하고 그 내용을 정리하면서 글을 작성하게 되었습니다.참고http://aispiration.com/xwmooc-sc/novice/sql/07-join.htmlSQL 실습 사이트 [w3schools]https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all 테이블이 여러 개 있어 JOIN등 튜플을 조합연습을 하기 좋은 사이트 [sqltest]http://sqlfiddle.com/ 테이블 추가가 가능한 사이트 " }, { "title": "스프링 입문 7 - 3.스프링 웹 개발 기초 - MVC와 템플릿 엔진", "url": "/posts/Inflearn-spring7/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-01 15:00:00 +0900", "snippet": "MVC과거에는 view와 controller 를 구분하지 않았습니다. 그래서 view에 controller 기능을 넣어서 JSP를 가지고 개발했습니다. 이 방식을 모델 1 방식이라고 부릅니다.지금은 MVC 패턴 방식으로 개발을 많이 합니다. 개발을 할 때, 기능에 따라 분리해서 개발해야 효율이 늘어나고 유지보수가 수월해집니다.M : Model - 화면에서 필요한 요소를 모델에 담아 View 에 넘겨주는 역할V : View - 보여지는 것에 초점을 맞추어 개발C : Controller - 비즈니스 로직과 관련되어 있거나 서버와 관련된 처리하는 데에 집중하여 개발새로운 controller 생성HelloController 클래스HelloController 클래스에 hello-mvc controller 생성합니다.hello-mvc는 파라미터를 받을 수 있게 @RequestParam(&quot;name&quot;) 과 String name, Model model를 입력합니다.이전 hello controller는 hello! 라는 값으로 고정이 되어있었다면, name은 웹 사이트에서 입력받은 값을 그대로 model로 전달합니다.model.addAttribute()를 사용해서 파라미터에서 넘어온 name을 model로 넘겨줍니다.attribureName &quot;name&quot;이 key 이고 사용자가 입력한 name이 전달됩니다.return &quot;hello-template&quot;을 통해 hello-template.html로 이동합니다.hello-template.htmltempaltes 디렉토리에 hello-template.html 을 생성하고 다음과 같은 코드를 입력합니다.&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p th:text=&quot;&#39;hello &#39; + ${name}&quot;&amp;gt;hello! empty&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;thymeleaf 를 통해 서버없이 html을 바로 웹브라우저에서 열 수 있습니다.hello! empty는 hello-template.html 파일을 템플릿 동작이 없을 때 웹 브라우저에서 출력되지만 템플릿이 동작하여 hello-template.html을 열면 hello! empty -&amp;gt; &#39;hello &#39; + ${name} 로 치환되어 출력됩니다.$는 model 에서 key 값이 name인 value로 치환하여 출력한다는 의미입니다.즉 hello! empty은 서버 없이 html 파일을 볼 때, 입력하는 코드 입니다.스프링을 실행하고 http://127.0.0.1:8080/hello-mvc에서 다음 화면을 확인할 수 있습니다.에러 화면이 나왔지만 이것이 정상입니다. 에러를 고치기 위해서는 에러 수정 를 확인해주세요정상적으로 웹 화면에 html을 출력하기 위해서는 http://127.0.0.1:8080/hello-mvc 뒤에 ?name=spring!!을 붙여줍니다.이는 HTTP에서 GET 방식으로 파라미터를 넘겨주는 방식으로 다음과 같이 에러 페이지가 나오지 않고 정상적으로 웹 화면이 나오는 것을 확인할 수 있습니다.스프링을 시작하고 name 파라미터가 어떻게 hello-template.html에 넘어가는지를 순서를 정리한 화면입니다.여기서 model이 View에 필요한 요소들을 전달하는 것을 확인할 수 있었습니다.오늘 강의를 요약하면 다음과 같습니다.웹 브라우저에서 http://127.0.0.1:8080/hello-mvc를 스프링 부트로 넘기면 스프링 부트를 띄울 때 같이 띄우는 내장 톰캣 서버를 먼저 거칩니다.내장 톰캣 서버는 http://127.0.0.1:8080/hello-mvc를 스프링 부트로 보냅니다.hello-mvc 가 helloController 메소드에 매핑이 되어 있으므로public String HelloMvc HelloMvc 라는 메소드를 호출하고 model로 key=name, value = spring 데이터를 hello-template와 같이 리턴합니다. (ViewResolver에 전달합니다.)ViewResolver는 templates 디렉토리에서 hello-template.html을 찾아서 thymeleaf 템플릿 엔진에 hello-template.html을 넘깁니다.thymeleaf 템플릿 엔진이 렌더링(변환 및 처리)을 해서 HTML을 웹 브라우저에 반환합니다.변환되어 웹 브라우저에 반환된 HTML은 원본 hello-template.html 코드와 다른것을 확인할 수 있습니다.이전 강의에서는에러 수정에러를 고치기 위해 IntelliJ 로그화면에 찍힌 WARN 14796 코드를 확인해보았습니다.WARN 14796 — [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.bind.MissingServletRequestParameterException: Required request parameter ‘name’ for method parameter type String is not present]parameter &#39;name&#39; 가 없다는 에러입니다.HelloMvc 메소드의 name 파라미터 부분을 다음과 같이 고쳐줍니다.커서를 놓고 Ctrl + P 를 누르면 옵션을 선택할 수 있습니다. required 를 입력하고 Ctrl + P 를 눌러 false 를 넣어줍니다.cf) true는 반드시 입력값이 있어야 한다는 의미입니다.이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 6 - 3.스프링 웹 개발 기초 - 정적 컨텐츠", "url": "/posts/Inflearn-spring6/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-03-01 15:00:00 +0900", "snippet": "웹 개발은 크게 3가지 방법으로 나뉩니다. 정적컨텐츠 서버에서 처리나 실행없이 파일을 웹 브라우저에 바로 표현하는 것 스프링 부트는 정적 컨텐츠 기능을 자동으로 지원합니다. MVC와 템플릿 엔진 템플릿 엔진: 정적인 HTML을 바로 웹 브라우저로 보내는 것이 아니라 서버에서 프로그래밍으로 처리 및 변형을 통해 MTML을 동적으로 표현하여 웹 브라우저로 보내는 것입니다. MVC: Model, View, Controller를 통해 템플릿 엔진이 동적으로 웹을 표현하는 것으로 템플릿 엔진을 통해 View를 표현합니다. 요즘은 MVC와 템플릿 엔진으로 개발을 많이 함 APIJSON 데이터 포맷으로 데이터를 전송하는데 정적 컨텐츠스프링 부트 문서에서 정적 컨텐츠에 대한 설명을 확인할 수 있습니다.링크: 스프링 부트 문서 - 정적 컨텐츠 설명스프링 부트는 static 디렉토리를 먼저 확인하고 없으면 /public or /resources or /META-INF/resources의 폴더들을 확인하여 정적 콘텐츠를 서비스합니다.static 이라는 디렉토리에 hello-static이라는 html파일을 생성했습니다.스프링 부트를 실행하고 http://127.0.0.1:8080/hello-static.html에 접속을 했습니다.이렇게 정적 파일이 서버의 어떠한 처리나 변형 없이 바로 웹 브라우저에 적용되는 것을 확인할 수 있었습니다.원리는 크게 이해하면 다음과 같습니다. 웹 브라우저에서 http://127.0.0.1:8080/hello-static.html 를 검색합니다. 내장 톰캣 버서에서 웹 브라우저의 요청을 받아 스프링 부트로 http://127.0.0.1:8080/hello-static.html 입력을 넘깁니다. (1) 스프링의 controller 쪽에서 hello-static와 관련된 것이 있는지 찾아봅니다. 컨트롤러가 우선순위를 가집니다. 이전 강의에서 hello 라는 컨트롤러는 있었지만 hello-static은 컨트롤러가 없었습니다.(2) resouces 디렉토리에 static/hello-static.html 이라는 파일을 찾습니다.(3) static/hello-static.html 있으므로 아무런 변형 없이 웹 브라우저에 반환을 합니다. 이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "백준 1931 회의실 배정 (python)", "url": "/posts/BOJ-1931/", "categories": "BOJ, Greedy", "tags": "BOJ, Greedy, 1931", "date": "2022-02-28 16:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/1931풀이제 코드는 다음과 같습니다.import sysN = int(sys.stdin.readline().rstrip())a = []for i in range(N): start, end = map(int, sys.stdin.readline().split()) diff = end - start a.append([start, end, diff])a.sort(key=lambda x:(x[1], x[0], x[2]))end = a[0][1]count = 1for i in range(1, N): if end &amp;lt;= a[i][0]: #print(a[i]) end = a[i][1] count += 1print(count)이 문제는 회의실 사용표를 통해 회의가 가능한 최대 개수를 찾는 문제이다. 그리디 알고리즘을 통해 가장 빨리 끝나는 회의를 선택하고 바로 시작하는 회의를 찾으면 됩니다.저는 입력값을 보고 끝나는 시간 기준으로 정렬이 되어있길래 정렬이 된 상태로 입력이 되는 줄 알고 따로 정렬을 해주지 않았습니다그런데 8%에서 틀렸습니다 라고 결과가 나오길래 바로 정렬을 해주었습니다.먼저 end 와 start로 데이터를 구분지어 받고 a라는 리스트에 회의 시간을 넣어주었습니다.그리고 처음에는 시작하는 시간보다 두 시간의 차이가 적을 수록 많은 회의를 배정할 수 있다고 생각하여 diff 라는 변수를 선언하고 그 변수를 2순위로 a를 정렬하였습니다.하지만 다음과 같은 경우 회의를 지나치는 경우가 있어 시작시간을 2순위로 하고 두 회의시간의 차이를 3순위로 하여 정렬을 했습니다.4 44 55 5이 경우 만약 두 시간의 차이를 2순위로 정렬하였다면4 45 54 5순으로 정렬이 되어 4 5 는 선택하지 못하여 최대 회의 개수를 찾지 못했습니다.이번 문제는 시간이 오래 걸렸어도 참조 없이 제 스스로 문제를 해결하였습니다." }, { "title": "백준 10610 30 (python)", "url": "/posts/BOJ-10610/", "categories": "BOJ, Greedy", "tags": "BOJ, Greedy, 10610", "date": "2022-02-28 16:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/10610풀이제 코드는 다음과 같습니다.import sysnum = sys.stdin.readline().rstrip()def sol(): if &#39;0&#39; not in num: #입력에 0 이 없으면 30 배수 안되므로 -1 print(-1) return num_list = list(num) # num_list.sort(reverse=True) # SUM = 0 for i in range(len(num_list)): # 각 자리수의 합이 3의 배수이면 num은 3의 배수 SUM += int(num[i]) if SUM % 3 == 0: print(&quot;&quot;.join(num_list)) return else: print(-1) returnsol()모범 답안import sysnum = list(map(int, sys.stdin.readline().rstrip()))if sum(num)%3 == 0 and 0 in num: num.sort(reverse=True) print(&#39;&#39;.join(map(str, num)))else: print(-1)저는 입력받은 숫자를 list로 변환한 후, 각 원소를 더해서 3의 배수인지 판별했습니다.하지만 모범 답안은 sum 함수를 이용하고 join 함수에서 map 함수를 이용하여 바로 숫자로 된 list를 str로 바꿔주어 간결하고 직관적인 코드가 된 것을 확인할 수 있었습니다.sum 함수는 모든 경우에서 되는 것이 아니라, 리스트 형태에서 원소들 모두 숫자로 되어있어야 사용할 수 있었습니다.in 함수를 통해 찾고자하는 원소가 있는지 파악하기 위해서는 string 에서 ‘‘를 통해 바로 찾을 수 있는 것 뿐만 아니라 list 형태에서도 바로 찾을 수 있다는 것을 새롭게 알게 되었습니다.참고Python - 리스트를 문자열로 변환" }, { "title": "백준 11652 카드 (python)", "url": "/posts/BOJ-11652/", "categories": "BOJ, sort", "tags": "BOJ, sort, 11652", "date": "2022-02-27 22:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/11652풀이제 코드는 다음과 같습니다.import sysn = int(sys.stdin.readline())a =[]for i in range(n): a.append(int(sys.stdin.readline().rstrip()))a.sort()count = 1result = [[a[0], count]]for i in range(1, n): if result[-1][0] == a[i]: count += 1 result[-1][1] = count else: count = 1 result.append([a[i], count])result.sort(key = lambda x:(-x[1], x[0]))sys.stdout.write(str(result[0][0]))제 코드의 핵심은 입력받은 카드를 오름차순으로 정렬하고 result라는 리스트를 새로 만들어 정렬된 a 리스트에서 첫번째 원소를 넣었습니다.1 부터 n-1번째 인덱스까지 반복문을 통해 모든 a 리스트의 원소를 접근하여 result 에 넣은 원소와 다른 원소가 나올때 까지 같은 원소의 개수를 셉니다.그 후 result 리스트를 정렬하여 count가 내림차순으로 우선 정렬을 하고 count가 같다면 정수가 작은 순으로 정렬되게 했습니다.모범 답안import sysn = int(sys.stdin.readline())#a = []a={}for i in range(n): data = int(sys.stdin.readline().rstrip()) if data in a: a[data] += 1 else: a[data] = 1result = sorted(a.items(), key = lambda x:(-x[1], x[0]))sys.stdout.write(str(result[0][0]))a[i]와 result를 비교하여 코드를 작성할 경우 에러가 발생할 수 있는 여지가 많아져 직관적이지 못한 코드가 되었습니다. 저는 in 이라는 키워드를 사용하면 list 안에 원소가 존재하는지 아닌지를 빠르게 판별할 수 있으며 굳이 array 리스트를 정렬할 필요가 없다는 것을 새롭게 알고 코드를 다시 짜게 되었습니다.a 라는 입력받은 데이터를 in 키워드를 사용하여 저장하는 딕셔너리에 값이 이미 있으면 +1 을 하고 아니면 =1을 대입합니다.주의할 점은 여기서 a를 딕셔너리가 아닌 리스트로 사용하려면 a = [0]x(n+1) 로 초기화 하거나 정수의 최대값으로 초기화 해야하지만 이렇게 할 경우 불필요한 메모리 공간을 할당하므로 딕셔너리를 사용하는 것이 좋습니다. 알아서 key, value로 설정되어있기 때문입니다.최종 결과입니다.참고[백준] 11652 카드 (파이썬 Python)" }, { "title": "백준 10989 수 정렬하기 3 (python)", "url": "/posts/BOJ-10989/", "categories": "BOJ, sort", "tags": "BOJ, sort, 10989", "date": "2022-02-27 17:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/10989오답 분석저는 먼저 파이썬에 내장된 정렬 함수인 sort를 이용해서 풀려고 했습니다. 하지만 저번 2751 수 정렬하기 2 문제와 다르게 메모리 초과가 발생했습니다.그 이유는 입력되는 정수의 개수 N과 입력되는 정수의 최대 값 n의 차이를 제대로 파악하지 못했으며, 메모리 범위를 고려하지 않아 문제가 발생하였습니다.아래는 제가 처음 제출한 코드입니다.이 문제의 핵심은 메모리의 최대값은 8MB인 것과 입력되는 정수의 개수 N의 범위는(1 ≤ N ≤10,000,000)라는 것입니다.파이썬에서 정수 값은 기본적으로 4byte 메모리를 할당합니다. 만약 모든 데이터의 입력을 리스트에 저장한다면4byte * 10,000,000 = 40MB의 메모리가 필요합니다.이 문제의 핵심을 잘못 파악하여 문제를 푼 것입니다.저는 위 문제를 계수 정렬이라는 특이한 정렬 방식으로 해결하였습니다.계수 정렬계수 정렬은 다음 조건을 만족해야 사용할 수 있는 정렬 알고리즘입니다. 모든 데이터가 양의 정수여야 합니다. 데이터의 크기 범위가 제한되어 정수 형태로 표현 할 수 있을때 사용 가능 합니다. 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않아야 합니다.2.를 자세하게 설명하면 이 문제에서 입력되는 정수는 10,000보다 작거나 같은 자연수이다. 라는 조건이 있습니다.이는 데이터의 크기 범위가 10,000으로 제한 된 양의 정수를 의미합니다.따라서 위 10989 문제는 이 두 조건을 모두 만족하여 계수정렬로 풀 수 있습니다.계수정렬의 시간 복잡도는 O(N + K) 입니다.N = 데이터의 개수 (이 문제는 최대 10,000,000)K = 데이터 중 최대 값(10000)따라서 계수 정렬의 최대 시간 복잡도는 O(N)이며, 공간 복잡도는 4byte * 10,001 = 40KB = 0.04 MB 첫번째 코드 보다 1/10000로 줄어든 것을 확인할 수 있었습니다.계수 정렬은 값을 비교하며 순서를 바꾸는 것이 입력되는 양수와 깉은 인덱스를 하나씩 증가시키고 이를 처음부터 출력하는 방식입니다.for문을 1번만 실행하면 되기에 O(N+K) 가 되는 것 입니다.(K 가 나오는 이유는 N=2, 두 정수가 0, 999,999인 경우 N은 큰 K값에 의해 무시되어 O표기법으로 표현될 수도 있기 때문입니다.)계수 정렬을 이용하여 문제를 해결하였습니다.두 번째 코드 (정답)python 3 로 제출한 코드는 다음과 같습니다.import sysn = int(sys.stdin.readline().rstrip())a = [0]*(10001)for i in range(n): num = int(sys.stdin.readline().rstrip()) a[num] += 1# 내장 sort함수가 아닌 계수정렬이용하기#a.sort()for i in range(10001): # sys.stdout.write(str(a[i])+&quot;\\n&quot;) if a[i] != 0: for j in range(a[i]): print(i)하지만 이 코드를 PyPy3로 제출한 결과 메모리 초과라는 결과가 나와 틀렸습니다.sys.stdout.write(str(a[i])+&quot;\\n&quot;)코드를 사용하면 개행 문자를 없애고 파라미터를 위한 메모리 공간도 할당되지 않아서 메모리 문제를 해결할 수 있을 것 같아 코드를 아래와 같이 약간 수정하고 PyPy3 로 제출 해보았습니다.세 번째 코드 (정답)import sysn = int(sys.stdin.readline().rstrip())a = [0]*(10001)temp = 0for i in range(n): num = int(sys.stdin.readline().rstrip()) a[num] += 1# 내장 sort함수가 아닌 계수정렬이용하기#a.sort()for i in range(10001): if a[i] != 0: for j in range(a[i]): sys.stdout.write(str(i)+&quot;\\n&quot;)실행 속도가 3배 가량 향상 하였지만 메모리는 그만큼 4배 더 많이 사용하였습니다. 코드와 언어에 따라 시간과 공간의 trade-off 가 발생하는 것을 확인할 수 있었습니다.결론문제의 조건에 맞게 코드를 적절하게 작성하는 것이 전략이 코딩테스트를 통과하는 데에 큰 도움을 준다는 것을 깨달았습니다.참고10989 메모리 초과 해결 법[필독] 수 정렬하기 3 FAQ" }, { "title": "백준 2751 수 정렬하기 2 (python)", "url": "/posts/BOJ-2751/", "categories": "BOJ, sort", "tags": "BOJ, sort, 2751", "date": "2022-02-27 00:23:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/2751오답 분석저는 먼저 파이썬에 내장된 정렬 함수인 sort와 sorted를 이용해서 풀려고 했습니다. 하지만 모두 시간 초과가 발생했습니다.이를 해결하기 위해 바로 구글링을 하여 답을 찾지 않고 다음과 같은 생각과 과정을 통해 문제를 해결 하려고 했습니다. 파이썬의 정렬 내장함수인 sort와 sorted가 O(NlogN) 시간 복잡도를 가지고 정렬을 한다는데 이 정렬 알고리즘보다 더 빠른 퀵정렬 알고리즘을 사용해야 하나?-&amp;gt; 정답은 아니었습니다. 퀵정렬 또한 O(NlogN) 이라는 시간복잡도를 가지고 있어 똑같이 시간초과라는 문제가 발생했습니다. 1번도 아니라면 계수 정렬이라는 특수한 정렬알고리즘을 사용해야하나?-&amp;gt; 결과는 이번 생각도 틀렸습니다. 계수정렬의 시간복잡도는 N은 모든 정수가 양수인 상황에서 데이터의 개수를 나타내고, 데이터 중 최대값을 K 라고 할 때, O(N+K)인데 이것 또한 시간초과가 발생했습니다.문제가 제 힘으로는 해결되지 않아 구글링을 하였습니다. 결과는 생각보다 다른 곳에서 발생했습니다.제가 제출한 언어는 python 3 였는데 이는 인터프리터 언어 방식이라 코드를 위에서 부터 차례로 읽어가며 실행하는 방식입니다. 그런데 PyPy3는 JIT 컴파일 방식을 도입하여 자주 쓰이는 코드를 캐시하여 저장하는 기능이 있어 python 3보다 속도가 빠르다는 장점이 있었습니다. 이러한 차이로 인해 같은 코드라도 python 3는 복잡한 반복문에서 PyPy3 보다 속도가 느려 시간초과라는 문제가 발생했습니다.또한 제 코드는 데이터를 하나씩 읽을 때 마다 input() 함수를 사용했습니다. 하지만 다음 2가지의 경우 때문에 input()이라는 함수는 sys.stdin.readline()보다 시간이 더 걸리고 연산속도가 늦어지는 문제가 발생합니다. 내장 함수 input()은 prompt message를 인수로 받을 수 있습니다. 그리고 입력받은 값의 개행(\\n)문자를 알아서 삭제하여 리턴하는 기능이 있습니다. 저는 이러한 문제점을 파악하고 readline을 사용하여 더욱 빠른 실행속도를 얻을 수 있었습니다.sys.stdin.readline()하지만 제 코드를 PyPy3와 sys.stdin.readline()로 변경하여 제출하였지만 틀렸습니다라는 결과가 출력되었습니다.왼쪽이 틀린 코드, 오른쪽이 맞는 코드였습니다. 저는 보통 왼쪽 스타일로 array를 0으로 모두 초기화 하고 인덱스와 순서를 같게 하여 코딩을 합니다.저는 이렇게 코드를 짜더라도 출력할 때, 1부터 시작하니 문제가 없다고 생각하지만 0이라는 숫자가 섞여 저도 모르는 결과를 초래하는 경우가 생겨 문제가 발생할 수도 있습니다.그래서 리스트만 선언하고 데이터가 들어오는 경우만 추가하여 문제가 발생하는 요소는 없애기 위해 append 함수를 이용하였습니다.이렇게 코드를 작성하였더니 수많은 시행착오 끝에 문제를 해결할 수 있었습니다.결론만약 python3로 시간초과가 난다면 PyPy3로 제출을 동시에 고려하고 되도록이면 input() 함수 대신 sys.stdin.readline() 함수를 사용하여 시간을 단축시키도록 노력해야겠다고 생각했습니다.출처 및 참고 링크input과 sys.stdin.readline의 차이점2751에서 pypy와 python3 차이점" }, { "title": "스프링 입문 3 - 2.프로젝트 환경설정 - 빌드하고 실행하기", "url": "/posts/Inflearn-spring5/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-02-23 14:00:00 +0900", "snippet": "시스템 환경제 노트북 환경은 다음과 같습니다.java 11, windows 10gradlew로 빌드하기저는 프로젝트 Hellospring 폴더 주소창에서 cmd 를 입력하고 gradlew 로 빌드를 했더니 다음과 같은 에러가 발생했습니다. ERROR: JAVA_HOME is set to an invalid directory: ~~~~~ Please set the JAVA_HOME variable in your environment to match the location of your Java installation.이는 Java 환경 변수 경로를 잘못 설정한 에러때문에 발생하는것으로 파악됩니다.저도 초기에 설명을 따라 JAVA_HOME의 주소를C:\\Program Files\\Java\\jdk-11.0.14\\bin까지 설정하였지만 아래 사진처럼 bin을 삭제하니 정상적으로 gradlew로 빌드할 수 있었습니다.그 후 콘솔창에 다음 명령어를 입력하면 build 폴더가 다음과 같이 생성됩니다. gradlew build빌드가 정상적으로 작동되면 cd build를 cmd에서 입력하여 build 후 생성된 build 폴더의 libs 폴더로 이동을 합니다.libs 폴더로 이동을 하면 약 19M 정도의 jar 파일이 하나 생성되는 것을 확인할 수 있습니다.그 후 다음과 같은 명령어를 입력하여 jar 파일을 실행합니다. java -jar {프로젝트이름}-0.0.1-SNAPSHOT.jarIntelliJ에서 main 메소드를 run을 실행한 결과와 똑같은 화면을 볼 수 있습니다.서버를 배포할 때는 {프로젝트이름}-0.0.1-SNAPSHOT.jar 파일만 복사하여 서버에 넣고 java -jar 으로 실행하면 됩니다.이렇게 하면 서버에서 스프링이 알아서 동작합니다.build 폴더 삭제 gradlew clean이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 3 - 2.프로젝트 환경설정 - View 환경설정", "url": "/posts/Inflearn-spring4/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-02-23 14:00:00 +0900", "snippet": "Error 페이지를 Welcome Page 만들기src &amp;gt; main &amp;gt; java &amp;gt; resources &amp;gt; static 폴더에서 우클릭을 눌러 New &amp;gt; file을 클릭하고 새로운 file 하나를 생성합니다.파일명은 index.html을 입력합니다.그리고 다음 html 코드를 입력합니다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Hello &amp;lt;a href=&quot;/hello&quot;&amp;gt;hello&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;main 을 실행하고 브라우저에서 http://localhost:8080/ 를 입력하면 다음과 같은 페이지를 확인할 수 있습니다.이렇게 welcome 페이지를 쉽게 제작할 수 있습니다.스프링 부트는 스프링 생태계를 감싸서 편리하게 개발하는데 도움을 줍니다.스프링은 java enterprise web 애플리케이션 개발과 관련된 생태계를 모두 제공하므로 매우 광범위합니다. 그래서 모두 사용하지 못하고 필요한 것을 적절하게 찾아 사용하는 것이 중요합니다.welcome 페이지 제작은 다음과 같은 순서로 진행하면 수월합니다.먼저 spring.io를 접속하여 상단 바에서 Project Spring Boot 메뉴를 선택합니다.그 후 LEARN 의 2.6.3 버전(자산의 버전)의 Reference Doc. 를 선택합니다.Reference Doc페이지 왼쪽의 Web 메뉴를 선택하고 Cntl + F 눌러 Welcome 을 입력합니다.스프링 부트는 가장 먼저 index.html을 찾고 없으면 index 템플릿을 찾는 방식으로 작동을 합니다.Thymeleaf 템플릿 엔진index.html은 정적페이지로 아무런 동작을 하지 않고 페이지를 띄우기만 합니다. 하지만 Thymeleaf 템플릿 엔진을 사용하면 welcome 페이지를 변경할 수 있습니다. thymeleaf 공식 사이트: https://www.thymeleaf.org/ 스프링 공식 튜토리얼: https://spring.io/guides/gs/serving-web-content/ 스프링부트 메뉴얼: https://docs.spring.io/spring-boot/docs/2.3.6.RELEASE/reference/htmlsingle/스프링부트 메뉴얼 사이트에 접속해서 Template Engines 를 입력하면 제공되는 4가지 엔진을 확인할 수 있습니다. FreeMarker Groovy Thymeleaf Mustache이 중에서 저는 Thymeleaf를 선택했습니다.웹 애플리케이션의 진입점이 controler이기 때문에 IntelliJ로 돌아와서 controller를 만들어야합니다.위치는 Hello.Hellospring 패키지에 새로운 controller 패키지를 만듭니다.이후 controller 패키지에서 HelloController 라는 새로운 java class를 생성합니다.그 후 controller위에 @Controller 어노테이션을 추가합니다.그리고 위와 같은 코드를 작성합니다.이 코드는 웹 애플리케이션에서 /hello 라고 들어오면public String hello(Model model){ model.addAttribute(&quot;data&quot;, &quot;hello!&quot;); return &quot;hello&quot;; }이 메소드를 호출합니다.여기서 model은 MVC에서의 model을 의미합니다.그 다음 template 폴더에 hello.html 이라는 새로운 파일을 생성하고 다음과 같은 코드를 넣습니다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p th:text=&quot;&#39;안녕하세요. &#39; + ${data}&quot;&amp;gt;안녕하세요. 손님&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;th는 thymeleaf 를 의미하며 th=”http://www.thymeleaf.org” 를 통해 xmlns 스키마로 미리 선언되어있음을 확인할 수 있습니다.위 코드의 ${data}&quot; 는 HelloController 자바 클래스 안의 hello 메소드의 hello!로 치환이 되는데 이는 모델에서 key값을 의미 합니다.다시 main 메소드를 실행하면 http://localhost:8080/에서 다음과 같은 결과를 확인할 수 있습니다.동작 환경 그림먼저 웹 브라우저에서 http://localhost:8080/ 를 tomcat 내장서버에 보내면 tomcat이 스프링 컨테이너에게 질문을 합니다.그러면 스트링 컨테이너는 HelloController안에 있는 GetMapping을 통해(GET, POST의 그 GET 맞습니다.) hello를 확인하여 public String hello(Model model) 메소드를 실행시킵니다.그 후 스프링이 모델을 넣어 같이 보내줍니다. 그 모델안에 key는 data이고 값은 hello!를 넣어 hello 를 리턴합니다.이는 resources &amp;gt; templates 폴더에 있는 hello라는 파일을 찾아서 이것으로 렌더링 하라(이 화면을 실행시켜라)는 return 명령입니다.컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버(viewResolver)가 화면을 찾아서 처리합니다.즉, 스프링 부트 템플릿엔진 기본 viewName 매핑하는데 이는resources:templates/ +{ViewName}+ .html이런 구조로 되어있고 ViewName은 hello로 바뀌게 되어 hello.html이 열리게 됩니다.참고spring-boot-devtools 라이브러리를 추가하면, html 파일을 컴파일만 해주면 서버 재시작 없이 View 파일 변경이 가능합니다.인텔리J 컴파일 방법: 메뉴 build Recompile이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 3 - 2.프로젝트 환경설정 - 라이브러리 살펴보기", "url": "/posts/Inflearn-spring3/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-02-23 12:50:00 +0900", "snippet": "라이브러리 살펴보기External Libraries를 통해 Gradle이 알아서 당겨온 라이브러리를 확인할 수 있습니다.IntelliJ에서 왼쪽 하단의 네모 아이콘을 누르면 오른쪽 상단에 Gradle 메뉴가 생성되는것을 확인할 수 있습니다.여기서의 Dependencies가 라이브러리의 의존관계를 나타내며 저는 초기 spring boot starter를 통해 web와 thymeleaf 라이브러리만 가져왔으나 web와 thymeleaf이 필요한 라이브러리는 알아서 가져온 것을 확인할 수 있습니다.즉 web 라이브러리가 tomcat 라이브러리를 Embeded 하고 있습니다. 요즘에는 예쩐과 달리 tomcat 서버, WAS를 따로 설치하지 않고 이런 방식으로 라이브러리 하나만을 빌드해서 웹서버를 띄어 편하게 개발을 진행하고 있습니다.(*) 은 중복을 제거하여 나타낸것을 표시합니다.또한 스프링 부트 라이브러리를 쓰면 스프링 코어까지 알아서 한번에 다 가져와서 사용할 수 있게 만들어 줍니다.log현업에서 system.out.println()을 사용하지 않아야 하고 log로 꼭 출력을 해야합니다. log로 남겨야 심각한 에러를 확인할 수 있고 로그파일을 관리할 수 있게 된다.따라서 스프링 부트에서도 logging을 표준으로 설정하고 log할 수 있는 라이브러리를 알아서 가져와 준다.test와 관련된 라이브러리junit: test를 편하게 하게 도와주는 라이브러리정리 스프링 부트 라이브러리spring-boot-starter-web spring-boot-starter-tomcat: 톰캣 (웹서버) spring-webmvc: 스프링 웹 MVCspring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View)spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅 spring-boot spring-core spring-boot-starter-logging logback, slf4j 테스트 라이브러리spring-boot-starter-test-junit: 테스트 프레임워크-mockito: 목 라이브러리-assertj: 테스트 코드를 좀 더 편하게 작성하게 도와주는 라이브러리-spring-test: 스프링 통합 테스트 지원이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 2 - 2.프로젝트 환경설정 - 프로젝트 생성", "url": "/posts/Inflearn-spring2/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-02-22 13:50:00 +0900", "snippet": "프로젝트 생성사전 준비- java 11 설치- IDE: IntelliJ 또는 Eclipse 설치스프링 부트 스타터 사이트로 이동해서 스프링 프로젝트 생성합니다예전에는 스프링 프로젝트를 처음부터 다 만들었다면 요즘은 대부분 스프링 부트로 스프링 프로젝트를 만듭니다.- URL : &amp;lt;https://start.spring.io&amp;gt;실제 프로젝트 생성 Project필요한 라이브러리를 가져오고 빌드하는 라이프 사이클까지 모두 관리해주는 툴 과거는 Maven으로 만들었지만 요즘은 Gradle로 넘어오는 추세입니다. Language Java Spring Boot버전을 선택해야하는데 SNAPSHOT, M1은 정식 릴리즈된 버전이 아니므로 선택하지말고 정식 버전인 2.6.X을 선택해야 합니다. Group보통 기업의 도메인이나 이름을 넣지만 입문자는 크게 상관이 없으므로 Hello 를 넣습니다. Artfact빌드된 후 나오는 결과물로 프로젝트명이라고 보시면 됩니다. Name설정 값을 그대로 유지합니다. Description설정 값을 그대로 유지합니다. Pakage name설정 값을 그대로 유지합니다. Dependencies스프링 부트를 시작할 때 어떤 라이브러리를 가져와 쓸 것인지 결정합니다.저희는 웹 프로젝트를 생성할 것이기 때문에 spring web을 입력하고 선택합니다.추가로 웹 브라우저에서는 HTML이 보이듯이 스프링 부트에서 HTML을 만들어주는 Thymeleaf 템플릿 엔진이 필요합니다.모든 설정을 마치고 GENERATE 버튼을 클릭하여 다운로드를 받습니다.다운로드 받은 압축 파일의 압축을 풀고 IntelliJ 같은 IDE로 build.gradle 파일을 엽니다. 이후 90M 정도의 외부라이브러리를 다운 받기 때문에 완료가 될 때 까지 기다려줍니다.스프링 부트 파일 분석 .ideaIntelliJ 가 사용하는 설정 파일입니다. gradle gradle이 사용하는 파일입니다. src main: 실제 소스파일이 있습니다.resoruces : java 파일을 제외한 파일test: 테스트와 관련된 코드들이 들어감 build.gradleplugins: 지금은 스프링 부트가 가져온 라이브러리라고 간단하게만 이해하고 가면 됩니다.sourceCompatibility: Java 버전을 의미합니다. repositoriesmavenCentral: dependencies에 있는 라이브러리를 다운받는 공개된 사이트입니다.필요하면 특정 사이트를 추가하여 다운을 받을 수도 있습니다. dependencies위에서 가져온 thymeleaf, web등의 라이브러리에 대한 정보들을 갖고 있습니다.testImplementation: 요즘은 보통 테스트 라이브러리가 자동으로 들어갑니다. gitignoregit에는 소스코드만 올라가야 하므로 빌드된 결과물은 올라가면 안됩니다. 이 과정을 스프링 부트 스타터에서 자동으로 해줍니다.스프링 실행하기main 폴더의 HelloSpringApplication 이라는 클래스가 자동으로 만들어져 있습니다.여기에는 @SpringBootApplication 이라는 어노테이션(Annotation)이 만들어진 것을 확인할 수 있습니다.자바는 기본적으로 main 메소드에서 시작합니다.따라서 main 메소드 왼쪽의 초록색 &amp;gt; 표시를 누르고 실행을 누르면 됩니다. 저는 여기서 에러가 발생했는데 아래 해결하는 링크를 걸어두었으니 저와 같은 문제가 발생하신 분들은 URL로 이동하여 해결하시기 바랍니다.정상적으로 작동을 하면 다음과 같은 화면을 볼 수 있습니다.먼저 spring 이라는 문구가 나오며 그 아래 버전이 나오는 것을 확인할 수 있습니다.그리고 맨 아래에서 2번째 줄의 중간을 보면Tomcat started on port(s): 8080(http)라는 것을 볼 수 있는데 http 프로토콜을 사용하여 8080 포트를 열어놓은 것을 확인할 수 있습니다.브라우저로 Localhost:8080 을 입력하면 다음과 같은 에러페이지 화면을 볼 수 있습니다.이렇게 뜨면 스프링 부트 애플리케이션이 run 하면서 제대로 작동하는 것입니다.스프링 부트 애플리케이션이 스스로 tomcat 이라는 웹서버를 내장하고 있기 때문에 tomcat이라는 웹서버를 띄우면서 스프링부트를 자체적으로 같이 띄우게 되는 구조입니다.에러Java HotSpot(TM) 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.만약 여기서 위와 같은 에러가 뜬다면 다음을 확인해보시기 바랍니다.https://www.inflearn.com/questions/116973https://yellowh.tistory.com/105https://int-i.github.io/java/2020-11-21/openjdk-noverify-deprecated/저는 11버전을 사용해야하는데 15버전을 사용해서 13버전에서 에러가 발생했었습니다. 또한 IntelliJ에서 Gradle과 Project Stucture를 잘못 설정해주어 문제가 발생하였습니다이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "스프링 입문 1 - 1.강의소개 - 강의소개", "url": "/posts/Inflearn-spring1/", "categories": "Back-end", "tags": "Inflearn, Spring", "date": "2022-02-22 13:50:00 +0900", "snippet": "왜 Spring을 배워야 하는가?실무에서 제대로 작동하는 웹 어플리케이션을 제작하기 위해 스프링을 학습해야 함실제 동작하는 간단한 웹 어플리케이션 개발 과정 스프링 프로젝트 생성 스프링 부트로 웹 서버 실행 회원 도메인 개발 웹 MVC 개발 DB 연동 -JDBC, JPA, 스프링 데이터 JPA 테스트 케이스 작성프로젝트 사용기술 JPA (Java Persistence API)강의 목표스프링 학습의 제대로 된 첫 길잡이 역할 스프링 기술 그 자체에 매몰되지 않고 어떻게 사용해야 하는지에 초점 오래된 스프링 기술과 마이너한 기술은 배제 실무에서 필요한 최신 개발 트렌드 반영하여 스프링 학습학습 방법처음 부터 끝까지 코딩스프링 완전 정복 로드맵 스프링 입문 (V) 스프링 핵심 원리 스프링 웹 MVC 스프링 DB 데이터 접근 기술 실전! 스프링 부트이 글은 김영한님의 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 강의를 직접 정리한 내용입니다.출처: https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8#curriculum" }, { "title": "SQL 관련 기초 공부 - MySQL", "url": "/posts/MySQL-basic/", "categories": "SQL", "tags": "SQL, MySQL", "date": "2022-02-16 09:00:00 +0900", "snippet": "MySQL 소개 MySQL은 가장 널리 사용되고 있는 관계형 데이터베이스 관리 시스템(RDBMS: Relational DBMS). MySQL은 오픈 소스이며, 다중 사용자와 다중 스레드를 지원합니다. C언어, C++, JAVA, PHP 등 여러 프로그래밍 언어를 위한 다양한 API를 제공합니다. MySQL은 유닉스, 리눅스, 윈도우 등 다양한 운영체제에서 사용할 수 있으며, 특히 PHP와 함께 웹 개발에 자주 사용합니다. MySQL은 오픈 소스 라이센스를 따르기는 하지만, 상업적으로 사용할 때는 상업용 라이센스를 구입해야 합니다.출처: http://www.tcpschool.com/mysql/mysql_intro_introMySQL 장점 오픈 소스 라이센스를 따르기 때문에 커뮤니티 버전은 무료로 사용할 수 있습니다. 다양한 운영체제에서 사용할 수 있으며, 여러 가지의 프로그래밍 언어를 지원합니다. 크기가 큰 데이터 집합도 아주 빠르고 효과적으로 처리할 수 있습니다. 널리 알려진 표준 SQL 형식을 사용합니다. MySQL 응용 프로그램을 사용자의 용도에 맞게 수정할 수 있습니다.출처: http://www.tcpschool.com/mysql/mysql_intro_introMySQL vs MariaDBMaria DB는 MySQL과의 차이가 난 곳에서만 메뉴얼을 제공하지만 공통적인 부분은 제공하지 않는다. 따라서 공통적인 부분은 MySQL을 참고해야 합니다.지원과 레퍼런스가 MySQL이 더 많습니다.출처 : https://sabarada.tistory.com/164" }, { "title": "백엔드 관련 기초 공부 - 스프링(Spring)", "url": "/posts/Back-end-basic/", "categories": "Back-end", "tags": "Back-end, Spring", "date": "2022-02-16 00:00:00 +0900", "snippet": "Framework 프레임워크프레임워크는 소프트웨어를 만들때 뼈대가 되는 부분으로 큰틀을 제공하여 그 클에 맞춰 코딩하는 것이라면 라이브러리는 상용할수 있는 함수들의 모임으로 라이브러리를 호출하여 능동적으로 사용 가능프레임워크의 장점: 개발에 필요한 구조를 이미 코드로 만들어 놓음 →실력이 다소 부족한 개발자라고 하더라도 필요한 부분만 조립하는 형태로 개발이 가능 →개발이 쉬워지고 시간이 단축되며 일정한 틀 안에서 개발하기 때문에 어느정도 품질을 보장 받음출처: https://freestrokes.tistory.com/79프레임워크와 라이브러리 차이제어 흐름에 대한 주도성이 누구에게/어디에 있는가 즉 어플리케이션의 Flow(흐름)를 누가 쥐고 있느냐에 따른 차이가 있습니다.라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓰는 것입니다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어합니다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐입니다.반면에 프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 넣습니다.프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용되는 것입니다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식입니다.프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 합니다. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 합니다.간단히 정리해 보면 라이브러리는 그냥 함수들이나 기능 모음을 가져다가 쓰는 것이고. 프레임워크는 특정 디자인 패턴이나, 전처리 후처리에 필요한 동작과 기능들을 수행하기 위해서 프레임워크가 실행되다가 중간 중간에 특정 비지니스나, 특정 구현 단에서만 사용자의 코드를 lookup(검색)하여 사용하는 형태라고 할 수 있습니다.출처: Web ClubSpring 프레임워크 장점 1. 복잡함에 반기를 들어서 만들어진 프레임워크 엔터프라이즈급의 시스템이 실패하는 이유를 ‘복잡성’으로 보고 이를 해결하기 위해 나온 경량화된 프레임워크 일반적인 Java 클래스와 인터페이스를 이용하는 구조를 사용하고 EJB에 비해 가벼움 진입 장벽이 높지 않고 빠른 시간에 엔터프라이즈급의 시스템 구축이 가능 2. 프로젝트 전체 구조 설계에 유용한 프레임워크 이전에 다른 프레임워크들은 웹이나 데이터베이스 등의 전문적인 영역에 대해서만 지원하는 경우가 많았음 스프링은 어느 한 분야에만 집중하지 않고 전체를 설계하는 용도로 사용 가능 3. 다른 프레임워크들의 포용전체 구조에 집중하여 설계되었기 때문에 다른 프레임워크와 공존하는 방식으로 사용 가능다른 프레임워크들과의 통합을 지원하여 최소한의 수정이 가능기본 뼈대를 흔들지 않고 여러 종류의 프레임워크를 혼용해서 사용 가능 4. 개발 생산성과 도구의 지원스프링은 이론적으로 개발자가 이해해야하는 부분이 많지만 결과적으로 코드의 양은 줄어둠XML 설정을 이용하여 유지보수가 용이함STS, Eclipse, Intellij 등의 플러그인도 지원하여 새로운 개발 도구에 대한 별도의 적응 없이도 개발이 가능출처: https://freestrokes.tistory.com/79Spring 프레임워크 특징자바 기반 프레임워크엔터프라이즈급 어플리케이션을 구축할 수 있는 가벼운 솔루션이자, 원스-스탑-숍(One-Stop-Shop) 1. POJO 기반 구성(Plain Old Java Object) 스프링은 내부적으로 객체 간의 관계를 구성할 때 별도의 API 등을 사용하지 않는 POJO(Plain Old Java Object) 만으로 구성이 가능하도록 되어있습니다. 따라서, 일반적인 Java 코드를 이용하여 객체를 구성하는 방식 그대로 스프링에서 사용 가능합니다.이것은 특정한 라이브러리나 컨테이너에 기술에 종속적이지 않다는 것을 의미합니다. 이로 인하여 개발자는 가장 일반적인 형태로 코드를 작성하고 실행할 수 있기 때문에 높은 생산성과 유연한 테스트를 할 수 있는 장점을 갖게 됩니다. 2. IoC 컨테이너 (Inversion of Control) - 제어역전 제어의 흐름을 사용자가 컨트롤 하지 않고 위임한 특별한 객체에 모든 것을 맡기는 것자바 코드로 직접 객체간의 결합을 코딩하는 것이 아니라 컨테이너로 처리하여 ( -&amp;gt;DI)결합도를 낮춰 편리함을 제공 3. DL(Dependency Lookup) - 의존성 검색 컨테이너에서는 객체들을 관리하기 위해 별도의 저장소에 빈을 저장하는데 저장소에 저장되어 있는 개발자들이 컨테이너에서 제공하는 API를 이용하여 사용하고자 하는 빈 을 검색하는 방법입니다. 4. DI(Dependency Injection) - 의존성 주입의존성 주입이란 객체가 서로 의존하는 관계가 되게 의존성을 주입하는 것입니다. 객체지향 프로그램에서 의존성 이란 하나의 객체가 어떠한 다른 객체를 사용하고 있음을 의미합니다. IOC에서의 DI는 각 클래스 사이에 필요로 하는 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해 주는 것입니다. DI의 종류는 ‘생성자를 통한 주입’과 ‘set 메서드를 이용한 주입’으로 구분할 수 있으며, 스프링은 두 방식 모두를 지원하고 이에 대한 처리는 간단한 애노테이션으로 대체할 수 있습니다. 4. AOP(Aspect Oriented Programming) - 관점지향프로그래밍 스프링은 AOP를 통해 반복적인 코드를 줄이고 개발자가 핵심 비즈니스 로직에만 집중할 수 있도록 지원합니다. 대부분의 시스템에서 비즈니스 로직은 아니지만 보안, 로그, 트랜잭션과 같이 반드시 처리가 필요한 부분을 스프링에서는 횡단 관심사(cross-concern)라고 합니다. AOP는 이러한 횡단 관심사를 별도 모듈로 분리하는 프로그래밍 패러다임입니다. 스프링의 AOP는 AspectJ 모듈의 문법을 통하여 작성이 가능하고 이를 이용하여 개발자는 중복 코드를 줄이고 핵심 비즈니스 로직에만 집중하며 원하는 관심사의 유지보수가 수월한 코드를 구성할 수 있습니다. AOP에 대해 좀더 설명하면 다음과 같습니다. 아래는 OOP 에서의 로직의 흐름을 보여줍니다. 각 로직마다 권한, 로깅, 트랜잭션 처리에 대한 코드를 반복적으로 작성해줘야합니다. 위의 경우처럼 권한, 로깅, 트랜잭션을 관심사로 봤을 때 AOP에서는 이러한 관심사를 아래와 같이 모두 종단으로 삽입해줍니다. OOP에서 각 객체별로 처리했던 공통적인 관심을 분리하여 별도의 모듈로 만든 뒤 필요한 시점에 자동으로 소스코드가 삽입되도록 합니다. 출처: https://freestrokes.tistory.com/79 5. 완전한 기능을 갖춘 MVC Framework를 제공. MVC 구조(Model View Controller) (Model 2) : 사용자 인터페이스와 비지니스 로직을 분리하여 개발 하는 것입니다. MVC에서는 Model1과 Model2로 나누어져 있으며 일반적인 MVC는 Model2를 지칭합니다. ModelModel에서는 데이터처리를 담당하는 부분입니다. ViewView는 사용자 Interface를 담당하며 사용자에게 보여지는 부분입니다. ControllerController에서는 View에 받은 요청을 가공하여 Model(Service 영역)에 이를 전달 하며 Model로 부터 받은 결과를 View로 넘겨주는 역할입니다. Model, View, Controller를 나누는 이유는 소스를 분리함으로서 각 소스의 목적이 명확해 지고 유지보수하는데 있어서 용이합니다 model은 DB와 접근하는 계층 , VIEW는 JSP HTML들이 존재, CONTROLLER는 기능에 대한 구현을 담당합니다. 6. 스프링 프레임워크 모듈 스프링 프레임워크는 약 20개의 모듈로 구성되어 있습니다. 필요한 모듈만 가져다 사용할 수 있습니다. 7. 트랜잭션의 지원트랜잭션 : 더 이상 쪼갤 수 없는 최소 작업 단위, 여러 단계를 수행했을 때, 하나라도 실패하면 모두 취소되어야 하며 모두 반영하거나 반영하지 않습니다. 이렇게 함으로써 데이터의 무결성을 보장하는데 트랜잭션 처리는 개발자에게 큰 번거로움을 줍니다 스프링에서는 트랜잭션 처리를 애노테이션이나 XML로 설정할 수 있도록 지원합니다. 개발자가 매번 상황에 따라 코드를 작성해줘야 하는 번거로움이 줄어듭니다. 출처 부스트코스 : https://www.boostcourse.org/web326/lecture/58969?isDesc=false https://khj93.tistory.com/entry/Spring-Spring-Framework란-기본-개념-핵심-정리 https://alswns1201.medium.com/면접-대비-및-java-관련-이론-정리-6e3f0bbe0fd5" }, { "title": "백준 11055 가장 큰 증가 부분 수열 (python)", "url": "/posts/BOJ-11055/", "categories": "BOJ, DP", "tags": "BOJ, DP, 11055", "date": "2022-02-13 23:05:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/11055오답 정리이 문제의 점화식과 규칙은 11053 문제의 유형과 너무 비슷했기 때문에 빠르게 찾을 수 있었다. 하지만 사소한 실수로 인해 시간을 너무 많이 뺏기고 문제를 풀지 못하는 불상사가 발생했습니다.어디가 문제였는지 틀린 코드와 맞은 코드를 한눈에 비교하면서 분석해보도록 하겠습니다.ㅠㅠ 위 그림에서 차이점을 찾을 수 있나요? 저는 처음에 큰 문제가 없을 줄 알고 왼쪽처럼 코딩을 했습니다. 하지만 이렇게 코딩을 한 경우 예제는 커버가 되지만 모든 tast case를 만족 시킬수 없었습니다.그럼 어디서 문제가 발생하였을까요?다름 아니라 dp의 초기값에서 문제가 발생했습니다.저는 DP문제를 풀 때 무의식적으로 dp = [0]x(n+1) 로 초기화를 합니다. DP에는 메모나 DP테이블로 사용하기 위해 당연히 내가 값을 저장하려고 선언하는 것이기 때문에 값은 0 아니면 NULL 같이 없어야 한다고 생각했습니다.이 문제는 이러한 저의 부주의한 코딩하는 습관 때문에 거의 다 맞추고도 계속 틀리는 문제가 발생했습니다.저는 고작 이런거 때문에 틀렸다는 것에 너무 억울해서 스스로 예시를 대입하며 문제를 찾아냈습니다.만약 수열이 A = {100, 1, 2, 3} 이었다면 값은 어떻게 나와야 할까요?바로 1, 2, 3이 증가하는 수열이고 정답은 6이 나와야합니다. 저는 제 코드에서 어떻게 잘못된 값이 나오는지 알아보기 위해 변수 i의 for문이 끝날때마다 값을 출력해봤습니다.위 그림에서 처럼 값이 1이 덜 찍히면서 오답 5가 출력되었습니다.저는 왜 제 코드에서 이런 문제가 발생하는지 알아보기 위해 직접 문제를 따져가며 풀어보았더니 그제서야 알 수 있었습니다.if a[j] &amp;lt; a[i]: dp[i] = max(dp[i], dp[j] + a[i])위 점화식에서 i=2일때,dp[i] = a[i]이므로 a[i] 값을 dp[i]에서 처음부터 활용한다는 것을 확인할 수 있었습니다.보기에서 보여준 예시는 처음부터 i= 2 일때 101이 나와 a[i]의 값을 무시해도 문제가 발견되지 않았습니다.이러한 실수로 인해 (사실은 실력입니다..ㅜㅜ) 이번 문제에서 시간을 많이 뺏긴 것 같습니다…다음부터는 점화식이나 규칙을 찾을 때 초기값이나 기저를 잘 확인하고 DP에서 무조건 0으로 초기화 하지 않고 꼼꼼히 생각해서 코드를 짜보기로 다짐했습니다." }, { "title": "졸업작품 프로젝트", "url": "/posts/A.I.R-app/", "categories": "Capstone Design, A.I.R", "tags": "Kwangwoon Univ., Advantech", "date": "2022-02-12 17:30:00 +0900", "snippet": "소개팀명: 망서리지마팀원: 양설희, 김민소, 심현재, 정하영주제: 스마트 캠퍼스를 위한 공기질 관리 시스템 구축 (20.07 ~ 21.06)이름: A.I.R (Air InfoRmaiton)기능: 광운대학교 캠퍼스 주요 시설 내부의 온/습도 및 유해물질의 상태를 파악하여 실시간으로 정보를 제공 1. 개발 배경최근 코로나19로 인해 실내에 있는 시간이 증가함에 따라 실내 환경에 대한 시도 군 차원의 관심과 각 기업의 관심이 증가하고 있습니다. 또한, 국민의 삶의 질 개선 욕구가 증가함에 따라 부적절한 실내 환경에 대한 우려가 증가 하는 추세입니다.현존하고 있는 공기질 관련 앱들은 대부분 미세먼지에 대한 수치만 나타내고 있고, 한눈에 알아보기는 쉽지 않습니다. 또한 기상청의 정보를 그대로 가져오는 것들이 많아 특정 지역에 적용하기는 쉽지 않습니다.2. 개발 내용1) 공기질 센서에서 취득한 데이터를 가공해 실시간으로 DB에 전송하는 시스템 설계 - 센서에 대한 펌웨어 설계 및 제작 - DB와 LoRa Gateway 연결 - DB의 데이터를 받아와 시각화 작업 진행2) DB에서 데이터를 분석하고 데이터를 사용자가 인지하고, 공기질 관리 시스템에 쉽게 접근하고 편리하게 사용하도록 하는 앱 개발 - DB 데이터를 가공해 앱으로 전송 - 사용자 접근이 쉬운 앱 구조 설계3. 개념 설계 (구조 설계)IoT 기능을 가지는 아두이노 기반 센서를 바탕으로 센서에 맞게 펌웨어를 설계한 뒤, 센서로부터 데이터를 받아와 WISE-3610 를 이용해 데이터베이스에 저장된 현재의 공기질 데이터를 보내줍니다.데이터베이스에 수집된 데이터를 기반으로 사용자가 인지하기 쉽게 정보를 시각화 한 후 Restful 기반의 서버 DB에 저장된 정보를 Restful API를 애플리케이션에서 확인할 수 있도록 하였습니다.데이터 전송의 기반은 LoRa 통신으로, 비교적 원거리를 지원하여 프로젝트에서 요구하는 지정된 구역 내 온/습도 및 유해물질의 상태를 파악할 수 있게 해줍니다.4. 역할 성 명　　 역 할 양 설 희 WISE 1510 센서 보드의 펌웨어 업로드를 위한 프로그램의 세팅과 펌웨어 bin 파일 제작. 김 민 소 웹 서버의 데이터를 RESTFul API를 활용하여 애플리케이션으로 연동. Volley와 Gson를 사용하여 애플리케이션과 웹 간의 Http Connection을 함. 안드로이드 애플리케이션 UI/UX 기획 및 제작. 심 현 재 센서별 코드 제작 및 github에 업로드 후 코드별 작동, 구동을 위한 수정과 센서별로 보드 연결 후 테스트 진행 정 하 영 아두이노 센서의 아날로그 데이터의 가공식 및 활용법 조사 및 펌웨어에서의 적용을 하고 센서를 보드에 연결. 5. 실행화면현재는 앱을 실행 하여도 위 사진처럼 실행되지 않습니다. 먼저 게이트웨이를 활성화시키고 코드의 웹 서버와 일치하게 ID와 비밀번호를 Http 헤더에 넣어줘야 합니다.6. 게이트웨이 WISE-3610 무선 IoT LoRa 프라이빗 네트워크 게이트웨이 퀄컴 Atheros 쿼드-코어 ARM Cortex-A7 SoC 빌트인 듀얼 밴드 동시 와이-파이 MU-MINO (2x2) WAN x1/ LAN X1 Gigabit 이더넷 모드버스 TCP 및 모드버스 RTU 네트워크 통합 Ipsec/L2TP VPN Traffic Encryption 소프트웨어 탑재로 다양한 네트워크 활용 가능 하드웨어 모듈화 설계 오픈WRT BSP 임베디드 웹 UI 유저 인터페이스 더보기: https://www.advantech.co.kr/products/08a68eee-c464-4d08-8e1a-f251e70ab40f/wise-3610/mod_3d1f1d3e-ef7b-4394-b66d-312da675e28c7. WISE-3610 Software Functionality WEB GUI를 이용해서 WISE-3610 게이트웨이의 설정들을 변경할 수 있습니다.8. WISE-1510 M2.COM LoRa IoT Node (LoRa: Long Range) wireless module Built-in LoRa / LoRaWAN connectivity Great for Low Power Wide Range application 더보기: https://www.advantech.co.kr/products/08a68eee-c464-4d08-8e1a-f251e70ab40f/wise-3610/mod_3d1f1d3e-ef7b-4394-b66d-312da675e28c유해물질을 감시하는 센서를 WISE-1510이 결합된 보드에 장착하여 센서 값을 게이트웨이가 웹 서버로 보내는 방식으로 진행했습니다.8. Device-On 소개 Device-On에 연결된 IoT 장비를 중앙에서 한번에 관리하게 해주는 소프트웨어 (PaaS) 센서들이 WISE-3610 게이트웨이로 보낸 데이터 값을 실시간으로 모니터링 할 수 있으며 원격으로 소프트웨어 업데이트를 진행하는 등 여러가지 기능을 포함 DB 및 Dashboard 시각화 구현 용이 Restful API를 활용하여 애플리케이션 개발 가능 더보기: https://www.advantech.co.kr/products/550836fd-a062-4780-8416-3b742bc7fb16/deviceondm/mod_167c9c1d-59e6-4ed7-b42c-0029be022cb19. 실제 Device-On에서의 sensor값 확인개인 공부 클라우드 서비스의 종류 IaaS(Infrastructure as a Service, 아이아스)서비스로 제공되는 인프라스트럭처로 개발사에 제공되는 물리적 자원을 가상화함인터넷을 통해 사용자가 원하는 만큼의 ‘인프라’를 활용할 수 있는 방식음식을 만드는 과정으로 비유하면 요리할 수 있는 가스레인지나 조리도구등의 기본 사항만 제공되고 식재료 및 세팅 수저등은 개인이 준비해야 하는 상황 PaaS(Platform as a Service)서비스로 제공되는 플랫폼으로 개발사에 제공되는 플랫폼을 가상화함개발자들을 위한 클라우드 서비스라고도 하며 개발자가 코드만 개발해서 바로 적용할 수 있도록 리소스가 모두 포함되어있는 플랫폼이 제공되는 형태IaaS가 기본적인 조리 도구를 빌려주는 개념이라면 PaaS는 재료 까지 준비되어 조리만 하면 되는 상황 SaaS(Software as a Service)서비스로 제공되는 소프트웨어로 고객에게 제공되는 소프트웨어를 가상화함돈을 지불하면 모든 것이 구축된 소프트웨어를 바로 사용할 수 있는 형태로 대중에게 가장 익숙한 방식SaaS는 음식을 조리하는 것이 아닌 식당에서 음식을 시켜 먹거나 배달 시켜먹는 방법 " }, { "title": "Algorithm 1.DP", "url": "/posts/How-to-Solve-DP/", "categories": "Algorithm", "tags": "BOJ, DP, Algorithm, Dynamic Programing, Python", "date": "2022-02-11 00:30:00 +0900", "snippet": "동적 프로그래밍, 동적 계획법 (Dynamic Programing)다이나믹(Dynamic)의 유래다이나믹 프로그래밍에서 다이나믹의 의미는 동적할당의 다이나믹과 다릅니다. 동적할당에서 다이나믹은 프로그램이 실행되는 도중에 메모리를 동적으로 할당하는 자료구조 기법으로 메모리 공간을 낭비하지 않기 위해 사용합니다.하지만 다이나믹 프로그래밍에서 다이나믹의 의미는 크게 의미를 부여하지 않습니다. 다이나믹 프로그래밍을 먼저 만든 사람도 이름이 단지 멋있어서 다이나믹을 붙였다고 합니다.DP의 장점다이나믹 프로그램이은 메모리 공간을 사용하여 연산속도를 높이는 장점이 있습니다.DP의 방식 2가지 탑-다운 (Top-Down) 재귀 함수를 이용해서 DP를 작성하는방법으로 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식으로 메모이제이션(memoization)을 사용하여 이전에 푼 결과를 테이블이나 리스트에 저장합니다. DP의 대표적인 문제인 피보나치 수열을 간단하게 탑 다운 방식으로 코드를 작성하면 다음과 같습니다. dp = [0]*(n+1)def sol(x): if x == 1 or x == 2: return 1 if dp[x] != 0: return dp[x] dp[x] = sol(x-1) + sol(x-2) return dp[x]print(sol(n)) 바텀-업 (Bottom-up) 반복문을 이용하여 작은 문제부터 풀어 점점 큰 문제를 해결하는 방식으로 탑-다운 방식처럼 메모하는 방법을 채택하지만 바텀 업 방식에서는 메모이제이션이라는 말을 사용하는 대신 ‘DP 테이블’ 또는 Tabulation 이라는 용어를 사용한다고 합니다. 하지만 그 본질은 메모이제이션과 크게 다르지 않습니다. 피보나치 수열을 바텀-업 방식으로 작성하면 다음과 같습니다 dp = [0]*(n+1)dp[1] = 1 #기저dp[2] = 1 #기저for i in range(3, n+1): dp[i] = dp[i-1] + dp[i-2]print(dp[n]) DP 문제 조건다이나믹 프로그래밍을 사용할 때는 다음과 같습니다. 작은 문제의 계산들이 반복적으로 일어나고 (Overlapping Subproblems, 겹치는 부분 문제) 같은 문제를 구할 때 마다 문제의 정답이 같은 경우 (Optimal Substruction 최적 부분 구조). DP 풀이, 접근 방법 1. DP를 풀 때, 먼저 규칙성을 찾습니다. 대부분 시간이나 공간의 변화에 따라 현재와 과거를 비교하여 규칙이나 변화 유형들을 찾아냅니다. 2. 그 규칙 속에서 반복되는 계산을 찾아내고 이를 점화식으로 표현합니다. 3. 반복되는 계산을 저장할 리스트나 배열같은 메모리 공간을 할당합니다. (Tabulation) 4. 뒤에 오는 값은 무시하고 앞에서 계산한 결과를 이용하여 점화식을 표현합니다. 5. 기저가 필요 할 땐 (basis, 피보나치의 dp[1], dp[2] 같은 초기 값) 먼저 선언합니다. 6. 반복문으로 min, max, 또는 연산하여 현재 값을 리스트나 테이블에 저장합니다.저는 최대한 DP 문제를 바텀-업 (반복문)을 이용해서 해결하려고 노력하고 있습니다. 탑-다운 (재귀함수)를 사용하면 시간복잡도가 매우 커져 제한 시간 내에 문제를 풀지 못하는 경우가 발생할 확률이 높기 때문입니다.특히 DP 문제는 책으로 예제와 함께 기본기를 먼저 다진 후, 시간이 걸리더라도 답지 없이 스스로 점화식을 생각해내는 힘을 기르는 것이 가장 중요한 것 같습니다." }, { "title": "백준 2156 포도주 시식 (python)", "url": "/posts/BOJ-2156/", "categories": "BOJ, DP", "tags": "BOJ, DP, 2156", "date": "2022-02-11 00:00:00 +0900", "snippet": "문제출처: https://www.acmicpc.net/problem/2156접근 방법각 잔의 순서를 a1 a2 a3 a4 a5 a6 ai (현재 i = 7) 이라고 하면,포도주를 마시는 경우의 수는 다음 3개의 경우의 수만 존재합니다.이를 점화식으로 나타내면 다음과 같습니다.정답 코드n = int(input())array = [0]*(n+1)dp = [0]*(n+3)for i in range(1, n+1): array[i] = int(input())dp[1] = array[1]#dp2[2] = array[1] + array[2]#dp3[3] = array[2] + array[3]MAX = 0for i in range(1, n+1): dp[i] = max(dp[i-1], dp[i-2]+array[i], array[i-1]+ array[i] + dp[i-3])print(dp[n])문제점, 시간이 오래 걸린 이유이 문제를 푸는데 꼬박 이틀이 소요되었습니다. 물론 다른 DP 문제도 건들였지만 이 문제를 해결하지 못하면 다른 문제는 더욱 해결 하지 못할 것 같은 오기가 생겨 이 문제를 먼저 해결하기로 다짐했습니다.처음 이 문제를 접했을 때 컴퓨터 처럼 앞에서 부터 차례로 계산 하지 않고 앞 과 뒤의 경우를 모두 따졌습니다. 그 결과 앞에서 계산한 바텀-업 방식을 활용하지 못하여 경우의 수를 통한 점화식을 찾아내지 못했습니다.또한 값을 저장하는 dp가 과연 그 i번째 인덱스에서 최대값인지 의문이 들어 일일이 확인하느라 시간이 오래 걸렸습니다.다른 풀이 (틀림)저는 처음 정답인 점화식을 세우고도 기저와 반복문을 잘못 설정하여 틀렸습니다. 그런데 그 점화식을 고치지 않고 순간의 dp에 저장된 최대값이 잘못되었다고 생각하여 조금은 다른 방법으로 접근하여 새로 풀었습니다. 여기서 시간이 많이 걸렸습니다.접근 방식은 다음과 같습니다.먼저 이전에 계산한 작은 값들을 저장할 리스트를 3개를 만들었습니다. 그리고 각 리스트 마다 규칙성을 찾아 누적을 저장하였습니다.dp1 리스트는 인덱스를 3으로 나눌때 나머지가 2로 떨어지는 경우 값을 더하지 않았고dp2 리스트는 3으로 나누어 떨어질 때 값을 더하지 않았습니다.마지막으로 dp3 는 나머지가 1일 경우 더하지 않았습니다.저는 이 경우를 각각 리스트를 선언해서 문제를 풀었습니다. dp를 하나만 선언하여 최댓값을 저장하는 과정에서 문제가 발생한다고 생각하여 따로 선언했습니다.위 방식으로 파이참에서는 정상적으로 작동하고 모든 문제도 풀리긴 했지만 메모리 공간이 많이 소요되는지 백준에서는 틀렸습니다 가 출력되었습니다.그래서 다시 문제를 리스트 하나로 제한하며 풀려고 노력했고 처음에 제가 새웠던 점화식으로 풀었더니 해결 되었습니다.아래는 틀린 코드입니다. 시간복잡도 뿐만 아니라 공간복잡도, 메모리도 코딩테스트에서는 중요하다는 것을 새롭게 배우게 되었습니다.n = int(input())array = [0]*(n+1)dp1 = [0]*(n+3)dp2 = [0]*(n+3)dp3 = [0]*(n+3)for i in range(1, n+1): array[i] = int(input())# 초기값 필요없음#dp1[1] = array[1]#dp2[2] = array[1] + array[2]#dp3[3] = array[2] + array[3]for i in range(1, n+1): if i%3 == 2: dp1[i] = dp1[i-1] dp2[i] = dp2[i-1] + array[i] dp3[i] = dp3[i - 1] + array[i] elif i%3 == 0: dp1[i] = dp1[i-1] + array[i] dp2[i] = dp2[i - 1] dp3[i] = dp3[i - 1] + array[i] elif i%3 == 1: dp1[i] = dp1[i-1] + array[i] dp2[i] = dp2[i - 1] + array[i] dp3[i] = dp3[i - 1]print(max(dp1[n], dp2[n], dp3[n]))" }, { "title": "Chirpy jekyll 테마에서 프로필 변경하기", "url": "/posts/Chirpy-theme-profil/", "categories": "jekyll", "tags": "blog, jekyll theme, Chirpy, profil", "date": "2022-01-29 00:10:00 +0900", "snippet": "프로필 변경 및 사진 업로드먼저 로컬에 이미지만을 저장할 새로운 폴더를 만들고 그 폴더를 자신의 GitHub에 푸시합니다. 여기서 주의할 점은 &amp;lt;자신의 github이름&amp;gt;.github.io안이 아닌 밖에 리포지토리를 생성합니다.git push 하는 법은 이전에도 많이 사용하였으니 생략하겠습니다._config.yml 파일에서 img_cdn 은 images 파일의 끝을 담당하고 있습니다.avatar 부분 프로필을 담당하고 있습니다.img_cdn https://cdn.jsdelivr.net/gh/: CDN 서버를 활용해서 js파일들을 전송하는 것인데 github 리포지토리에 있는 사진을 서비스 합니다.gh는 github의 약자입니다. 그대로 냅둡니다.자세한 사항은 jsdelivr에서 확인하면 됩니다. cotes2020/여기는 자신의 GitHub 이름을 입력합니다. chirpy-images사진들이 있는 리포지토리 이름입니다. &amp;lt;자신의 github이름&amp;gt;.github.io안이 아닌 밖에 리포지토리를 생성합니다. @f4e0354b674f65a53b8917f0f786ed2956898cc1’리포지토리의 버전을 의미합니다. 버전을 찾는 방법은 다음과 같습니다. 저는 Chripy GitHub를 예로 들겠습니다. Chripy jekyll 테마의 제작자의 GitHub의 chirpy-images로 이동합니다. 위 사진 순서대로 commons 커밋 메세지를 클릭합니다 그러면 위의 commit 옆에 버전이 나타나는데 이를 복사합니다. 이 버전을 @ 옆에 붙여넣기 합니다. avatar프로필로 저장하고 싶은 사진이 있는 경로의 주소를 작성합니다. 위에서 생성한 이미지 전용 폴더 안에 있어야 합니다.사진 업로드가 실시간으로 입력이 안되는 경우Chripy 테마의 프로필과 사진 업로드는 조금 특이한 방식으로 되어있습니다. 사진이 로컬에만 있으면 안되고사진을 GitHub에 업로드하여 아바타나 이미지를 블로그에 반영 할 수 있습니다. 이전의 커밋버전과 현재의 버전이 안맞으면 이미지 로드가 잘 안되는 경우가 있습니다.이 경우 이미지를 모두 GitHub에 업로드 한 후, 바뀐 버전을 _config.yml 파일에서 img_cdn 부분의 버전을 수정하여 로컬에서 작업해보시기 바랍니다. 그리고 이미지 폴더가 2개 이상인 경우 동시에 커밋을 해서 커밋 버전을 되도록 일치시키는 것이 좋습니다. 불가피 할 경우 최신의 버전을 img_cdn 버전에 입력하시면 될 것 같습니다.버전은 콘솔 창에서도 git log 통해 확인이 가능합니다.참조한 사이트여기는 제가 참조한 사이트입니다.https://chirpy.cotes.page/https://kkminseok.github.io/posts/startblog/https://blog.kimzinu.com/posts/jekyll-4/https://zeddios.tistory.com/1223?category=682196" }, { "title": "GitHub 블로그에 Chirpy jekyll 테마 (theme) 적용하기", "url": "/posts/jekyll-Chirpy-theme/", "categories": "jekyll", "tags": "blog, jekyll, theme, Chirpy", "date": "2022-01-27 15:22:00 +0900", "snippet": "jekyll 테마 찾기https://jekyll-themes.com/free/저는 이 많은 무료 테마 중에서 다음과 같은 이유로 chirpy 테마를 선택하게 되었습니다. 왼쪽에 카테고리나 네비게이터가 있어 사용자 입장에서 이동이 자유로우며 현재 위치가 어디인지 쉽게 파악이 가능함 검색 기능으로 쉽게 글이나 자료를 찾을 수 있음 프로필 사진 첨부와 브라우저 탭에 icon을 넣을 수 있어 차별화 된 블로그 제작 가능 블로그 첫 페이지에서 포스트의 제목과 글이 간략하게 나와서 복잡해 보이지 않음 jekyll 테마 중에선 비교적 유명하여 문제가 발생하면 다른 사람들이 사용했던 방법들을 찾아 볼 수 있음 꾸준한 관리로 최근까지 업데이트 되어있음이제 부터는 chirpy 테마 위주로 글을 작성하겠습니다. 다른 테마는 적용 되지 않을 수 있으니 참고 바랍니다!PrerequisitesJekyll, ruby, bundler 등을 사전에 설치해야 chirpy를 수월하게 설치할 수 있습니다.설치 방법은 제 이전 포스트에 나와있습니다. 주소는 아래와 같습니다.jekyll(지킬)로 GitHub 블로그 만들기만약 여기서 이해가 잘 안된다면 제가 참조한 블로그들에서 확인 부탁드립니다.블로그들은 이 포스트 제일 하단에 있습니다.참고사항저는 GitHub Desktop 앱을 사용해서 제가 작성한 커맨드를 모두 사용하지는 않습니다. GitHub Desktop 이 매우 편리하지만 모든 사람들이 GitHub Desktop 앱을 사용하지 않아서 커맨드 형식으로 포스트를 작성했습니다. 문제가 생기는 경우 메일 주세요!chirpy-starter로 레포지터리 생성저는 제가 참조했던 블로그 들과 다르게 했습니다. 먼저 아래 사이트로 접속해서 레포지터리를 새로 만듭니다.Chirpy-starter중요한건 리포지토리 이름을 &amp;lt;자신의 github이름&amp;gt;.github.io로 설정해야 합니다.만약 이전에 &amp;lt;자신의 github이름&amp;gt;.github.io로 레포지터리를 만드셨다면, 이 리포지토리를 삭제하고 다시 생성하시기 바랍니다.삭제하는 방법은 settings에 들어가셔서 맨 아래 가시면 Delete this repository를 선택하시면 됩니다.자신의 컴퓨터에서 원하는 위치에 이동해서cmd 나 Start Command Prompt With Ruby를 실행하여위에서 생성한 자신의 리포지토리 주소를 입력후 git clone을 실행합니다.또는 자신의 리포지토리를 깃허브에서 ZIP파일로 다운 받아 압축을 해제합니다.그 후 다음 명령어를 실행합니다. $ bash tools/init.sh만약 bash가 실행이 안되거나 bash가 설치가 안되어있는 경우 아래 사이트를 참조해서 bash를 설치하시기 바랍니다.Windows10 에서 bash 설치저는 bash 때문에 시간이 많이 뺏겼고 아무도 이 문제가 발생하지 않아 저 혼자 해결하느라 시간이 많이 걸렸습니다. 제가 이 글을 남기는 이유도 여기에 있습니다.init.sh 명령어는 &amp;lt;자신의 github이름&amp;gt;.github.io 폴더에서.travis.yml 파일과,docs 폴더,_posts폴더 안에있는 파일들을 삭제해주는 기능이 있습니다.(A) Gemfile.lock을 .gitignore 텍스트 파일 맨 아래에 추가하고 저장합니다. 그리고 Gemfile.lock을 삭제합니다.(A) 부분은 chirpy 블로그의 getting-started 포스트의 내용과 다르지만 저는 이렇게 해서 오히려 잘 되어 이 방법을 사용하고 있습니다. 자신에게 맞는 방법을 하면 될 것 같습니다.그리고 Gemfile.lock을 삭제해도 다시 생기는 경우가 있는데 계속 삭제 안해도 저는 잘 되어서 .gitignore 파일에만 Gemfile.lock을 추가하면 되는 것 같습니다.아까 git clone이나 ZIP파일을 압축 해제한 경로에서 다음 명령어를 실행합니다. $ bundle exec jekyll s첫 블로그 페이지 설정 및 변경_config.yml 파일을 열어서 수정 합니다. 저는 VScode 편집기로 다음과 같이 수정했습니다.timezone: Asia/Seoultitle: osnimtagline: Python, Android(java), React, Node.js, C++, C, Linux.url: “https://osnim.github.io”username: osnimname: osnimemail: alsth4@naver.comlinks: 는 다른 부분은 두고 url 부분만 수정했습니다.theme_mode: [light]아래 부터는 프로필 사진을 변경하는 부분입니다. 여기 자세한 부분은 따로 포스트 할 예정이니 일단 넘어가 주세요img_cdn: “https://cdn.jsdelivr.net/gh/osnim/Images@edc68e382d111f90dae130584bed36d2c5be1015”vatar: “/commons/hi_noglasses.jpg”Running Local Servergit clone을 실행한 위치 또는 chirpy 테마가 설치된 폴더 경로로 이동하셔서 다음 명령어를 실행합니다. $ bundle exec jekyll s로컬 서비스가 실행되고 다음 주소를 인터넷 브라우저 주소창에 입력해주시기 바랍니다.http://127.0.0.1:4000만약 로컬 서비스를 종료하고 싶은 경우cmd 나 Start Command Prompt With Ruby에서 ctrl + c 를 입력하면 됩니다.이 페이지는 다른사람은 보지 못하고 오로지 자신의 컴퓨터에서만 확인이 가능합니다.실제 GitHub 블로그에 적용하기위에서 변경한 사항이 모두 로컬 서비스에서 적용이 잘 되었으면 이제 자신의 github.io블로그에 chirpy 테마를 진짜로 적용시킬 차례입니다. 저는 블로그 글까지 적용 잘 되는지 https://github.com/cotes2020/jekyll-theme-chirpy/tree/master/_posts의 포스트들을 제 _post 폴더에 넣어 글이 잘 게시되는지 확인하는 방법으로 진행했습니다.cmd 나 Start Command Prompt With Ruby에서 git push를 진행합니다. git add --all git commit -m &quot;커밋 메시지&quot; git push -u origin main여기서부터가 가장 중요합니다. chirpy는 다른 jekyll 테마와 달리 브랜치가 main이 아닌 chirpy 제작자가 만든 gh-pages라는 branch를 새로 생성해서 bot을 이용하여 자동으로 pages build and deployment을 실행해서 GitHub에 반영합니다.이와 관련해서 자세한 사항은 chirpy getting-started 페이지를 확인하면 될 것 같습니다.만약 pages build and deployment에서 빨간 불이 들어온다면 글 제목이나 Gemfile에서 문제가 생긴 것이니 다시 한번 확인 부탁드립니다.글 제목의 경우 되도록 영어로 작성하기를 권장드리며, 띄어쓰기 대신 - 를 사용해주세요gh-pages라는 branch를 적용하는 방법은 자신의 GitHub 페이지로 이동해서 &amp;lt;자신의 github이름&amp;gt;.github.io 리포지토리로 이동합니다.그 후 Settings의 Pages 메뉴로 이동해서 Branch를 main에서 gh-pages로 선택하고 /(root)폴더는 그대로 놓고 save 버튼을 클릭합니다.만약 gh-pages Branch가 생성되지 않은 경우bash tools/init.sh 에서 문제가 생겼거나 Gemfile.lock에서 문제가 생긴 것일 수 있으니 .gitignore 파일에서 Gemfile.lock을 넣어보시고 안되면 리포지토리를 삭제하고 처음부터 다시 하기를 권장합니다. 저 또한 그랬습니다.save까지 잘 되었다면 이제 리포지토리의 Actions로 이동하셔서 블로그에 적용되는 진행사항을 볼 수 있습니다.Action에서 노란 불이 들어오며 진행상황을 알려줍니다. 평균 30초~ 2분 정도 소요되며 이보다 더 오래 걸린적도 있지만 5분을 넘기진 않는 것 같습니다.그리고 초록불이 들어와 GitHub 블로그에 적용이 되었다고 하더라도 실제 저희가 보는 데에는 시간이 더 걸리니 10초~30초 정도 블로그를 확인해보시기 바랍니다.저도 처음에는 변경할 때 마다 블로그에 적용했는데 이러면 시간이 오래 걸리고 바로 확인을 못하는 문제가 발생했습니다.그래서 지금은 로컬에서 먼저 수정을 하고 최종만 블로그에 포스팅하는 방식으로 진행하고 있습니다.혹시라도 잘 안되는 부분이 있으면 왼쪽 메일로 문의 주세요!제 블로그를 방문해주셔서 정말 감사합니다.참조한 사이트여기는 제가 참조한 사이트입니다.https://chirpy.cotes.page/https://kkminseok.github.io/posts/startblog/https://blog.kimzinu.com/posts/jekyll-4/https://zeddios.tistory.com/1223?category=682196" }, { "title": "jekyll(지킬)로 GitHub 블로그 만들기 (Windows10, 64bit)", "url": "/posts/jekyll-GitHub/", "categories": "jekyll", "tags": "Github, jekyll, theme", "date": "2022-01-26 21:00:00 +0900", "snippet": "Github 블로그 만들기 자신의 Github에서 Repository를 새로 만듭니다. 중요한건 Repository 이름을 &amp;lt;자신의 github이름&amp;gt;.github.io로 설정해야 합니다. 제 블로그는 osnim GitHub 블로그 입니다. README file을 체크합니다. (안해도 상관 없지만 저는 하는 것을 추천합니다.) 그 Repository를 로컬로 clone 합니다. ZIP파일로 다운받아서 압축을 풀어도 되고 HTTPS 주소를 복사하여 프롬프트에서 아래 명령어를 실행해도 상관없습니다 git clone 복사한 주소 압축을 푼 Explorer나 git clone을 실행한 위치에 Repository의 파일이 생성됩니다. 이 경로를 잘 기억해두셔야 합니다. git push git add --allgit commit -m &quot;커밋 메시지&quot;git push -u origin main 로컬에서 push한 github 블로그를 주소창에 넣어 확인합니다 https://&amp;lt;자신의 github이름&amp;gt;.github.io jekyll를 Github 블로그에 적용1. Ruby Install (Ruby 다운 및 설치)저는 이번 GitHub 블로그를 만들면서 jekyll(지킬)에서 제공하는 Theme(테마)를 사용했습니다.jekyll은 ruby라는 언어로 제작되었습니다.ruby installer 사이트 가셔서 Ruby를 다운받고 설치를 해야합니다. (참고로 저는 Windows10 64bit 운영체제를 사용하고 있습니다.)사이트에 들어가시면Ruby, we recommend that you use the Ruby+Devkit 2.7.X (x64) installer.라는 문구를 오른쪽에서 확인 할 수 있습니다.저도 안정된 Ruby+Devkit 2.7.5-1(x64) 버전을 사용했고 잘 되었습니다.설치시 옵션을 선택할 때 Use UTF-8 as default external encoding. 을 꼭 체크해야합니다.저는 3개 모두 체크했습니다.2. jekyll을 로컬에 설치Ruby 설치가 완료되면 Start Command Prompt with Ruby 프롬프트를 실행합니다.처음 실행하면 경로가 C:\\Users\\사용자이름 인데 여기에 다음과 같은 명령을 넣고 실행하여 로컬에 jekyll을 설치합니다.gem install jekyll bundler프롬프트 콘솔 창에서 이전에 clone한 로컬 경로인 github.io 폴더로 이동하여 다음 명령어를 순차적으로 입력합니다.3. Jekyll 생성 및 jekyll을 로컬 서버에서 실행jekyll new ./bundle installbundle exec jekyll serve이렇게 입력하고 http://127.0.0.1:4000/ 또는 http://localhost:4000/를 인터넷 주소창에 입력하여 로컬 서버에서 jekyll이 적용된 Github 블로그를 확인할 수 있습니다. 하지만 이는 자신의 컴퓨터에서만 확인 가능하므로 다른 사람도 접근 가능할 수 있게 Github repository에 push를 해줘야 합니다.&amp;lt;자신의 github이름&amp;gt;.github.io repository에 다음과 같은 명령어를 입력하여 push합니다.git add .git commit -m &quot; 커밋 메세지&quot;git push모두 입력 후 브라우저 주소창에 &amp;lt;자신의 github이름&amp;gt;.github.io를 입력하여 자신의 github 블로그를 확인합니다." }, { "title": "GitHub 블로그를 시작하기 앞서..", "url": "/posts/Beginning-Github-blog/", "categories": "blogging", "tags": "Github, blog, blogging", "date": "2022-01-26 21:00:00 +0900", "snippet": "내가 GitHub 블로그로 기록을 남기는 이유나도 이제 대학교를 졸업하고 제대로 취업 준비를 하려고 한다. 내 동기들은 모두 4학년에 취업준비를 시작하지만 나는 1학년 때 학점을 잘 챙겨놓지 못해서 4학년 1,2학기 21. 20 학점을 들었다. 그래서 취업 준비를 본격적으로 하지 못했다.4학년 때 자격증도 따고 서류도 넣어보고 필기시험도 보러 가며 나 나름대로 취업시장을 경험했지만 최선을 다해 취업 준비를 하진 못했다. 전공 수업과 학점이 그 당시에는 더 중요했기 때문이다.학점을 많이 복구해서 내 기준에서의 좋은 학점까지 만들 수 있었다. 또한 내가 배우고 싶은 강의를 들으며 원하던 공부도 다 해봤다고 생각해서 이제는 온전히 취업에 신경 쓸 수 있을 것 같다. 그래서 이번 주 부터 포트폴리오, 코딩테스트, CS에만 전념할 것이다.그래서 이렇게 처음 Github 블로그 작성에 보다 신경을 많이 쓰고 있으며 글도 많이 남길 것이다.예전의 나 였으면 Github 블로그만 만들고 그 과정에서 생긴 Error나 당황했던 내용을 모두 남기지 않고 글도 안 썼을테지만 지금은 최대한 기록들을 남기고 싶다.이렇게 복습하면서 공부도 되고, 다시 구글링하여 문제를 해결하는 번거로움을 덜어 낼 수 있을 것이다.하지만 가장 큰 이유는 내가 아무런 비용 없이 받았던 도움들을 또 다른 누군가에게 베풀수 있다고 생각하기 때문에 될 수 있으면 Github 블로그를 자주 작성할 계획이다." } ]
